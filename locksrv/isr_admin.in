#!!!PERLPATH!!

##########################################################
# isr_admin - Perform various ISR administrative functions
##########################################################

#
#                     Internet Suspend/Resume (R)
#           A system for capture and transport of PC state
#
#              Copyright (c) 2002-2004, Intel Corporation
#         Copyright (c) 2004-2009, Carnegie Mellon University
#
# This software is distributed under the terms of the Eclipse Public
# License, Version 1.0 which can be found in the file named LICENSE.Eclipse.
# ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES
# RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT
#

##############################
# Section 0: Standard prologue
##############################
use strict;
use Getopt::Long;
use File::stat;
use File::Copy;
use File::Basename;
use File::Temp qw/tempdir/;
use MIME::Base64 qw/encode_base64/;
use POSIX qw/ceil/;
use Socket;
use Sys::Hostname;
use Term::ANSIColor qw(:constants);
use constant {
	RCS_REVISION => "!!REVISION!!",
	LIBDIR => "!!LIBDIR!!",
	SYSCONFDIR => "!!SYSCONFDIR!!",
	STATEDIR => "!!STATEDIR!!",
	CHUNKSIZE => 131072,
	CHUNKSPERDIR => 512,
	KEYROOT_BYTES => 15,
	PASSWORD_BYTES => 9,
};
use lib "!!SHAREDIR!!";
use Server;
$| = 1; # Autoflush output on every print statement

# Function prototypes
sub encrypt ($$$$);
sub decrypt ($$$$);
sub getkeyroot ($$);
sub adduser ($);
sub deluser ($);
sub init_parceldir ($$);
sub finalize_parceldir ($$);
sub gen_uuid ();
sub parse_disk_size ($$);
sub get_maxkb ($$);
sub gen_chunks ($$$$$);
sub copy_chunks ($$$$);
sub copyparcel ($$$$$);
sub new_parcel ($$$$$$$);
sub makeparcel_gen_chunks ($$$$$);
sub makeparcel ($$$$$);
sub delparcel ($$);
sub prune ($$$);
sub getusage ();
sub keygen ($);
sub query ($);

#########################
# Section 1: Main routine
#########################

#
# Variables
#
my $result;
my $target;

# Command line
my $help;
my $parceldir;
my $parcel;
my $srcparcel;
my $verbose;
my $force;
my $command;
my $keyroot;
my $userid;
my $srcuserid;
my $retain;
my $version;
my $size;
my $memsize;
my $vmm;

# Server configuration
my %config = get_config();

#
# Parse the command line args
#
Getopt::Long::Configure("no_ignore_case", "bundling_override");
$result = GetOptions(
                     "f|force"         => \$force,
                     "h|help+"         => \$help,
                     "m|memsize=i"     => \$memsize,
                     "M|vmm=s"         => \$vmm,
                     "p|parcel=s"      => \$parcel,
                     "P|srcparcel=s"   => \$srcparcel,
                     "r|retain=i"      => \$retain,
                     "s|size=s"        => \$size,
                     "u|userid=s"      => \$userid,
                     "U|srcuserid=s"   => \$srcuserid,
                     "v|version=i"     => \$version,
                     "V|verbose+"      => \$verbose,
                     );
if ($result == 0 or $help) {
    usage();
}

#
# Extract the command name
#
if (@ARGV == 0) {
    usage("Missing command.");
}
if (@ARGV > 1) {
    usage("Too many commands.");
}
$command = $ARGV[0];

#
# Handle the special case where someone types "admin help"
#
if ($command eq "help") {
    usage();
}

#
# Make sure we have all the arguments we need for each command
#
if ($command eq "encrypt" or 
     $command eq "decrypt") {
    usage("Missing userid (-u)")
	if (!$userid);
    usage("Missing parcel (-p)")
	if (!$parcel);
    usage("Missing version (-v)")
	if (!defined($version));
    usage("Non-positive version number ($version)")
	if ($version < 1);
}

if ($command eq "getkeyroot") {
    usage("Missing userid (-u)")
	if (!$userid);
    usage("Missing parcel name (-p)")
	if (!$parcel);
}

if ($command eq "adduser") {
    usage("Missing userid (-u)")
	if (!$userid);
}

if ($command eq "deluser") {
    usage("Missing userid (-u)")
	if (!$userid);
}

if ($command eq "copyparcel") {
    usage("Missing userid (-u)")
	if (!$userid);
    usage("Missing parcel name (-p)")
	if (!$parcel);
    usage("Missing source userid (-U)")
    	if (!$srcuserid);
    usage("Missing source parcel (-P)")
	if (!$srcparcel);
    # -s is optional
}

if ($command eq "makeparcel") {
    usage("Missing userid (-u)")
        if (!$userid);
    usage("Missing parcel name (-p)")
	if (!$parcel);
    usage("Missing memory image size (-m)")
        if (!$memsize);
    usage("Missing parcel size (-s)")
        if (!$size);
    usage("Missing VMM type (-M)")
        if (!$vmm);
}

if ($command eq "delparcel") {
    usage("Missing userid (-u)")
        if (!$userid);
    usage("Missing parcel name (-p)")
	if (!$parcel);
}

if ($command eq "prune") {
    usage("Missing userid (-u)")
	if (!$userid);
    usage("Missing parcel name (-p)")
	if (!$parcel);
    usage("Missing number of versions to retain (-r)")
	if (!defined($retain));
}

#
# Process the command
#
if ($command eq "encrypt") {
    $keyroot = getkeyroot($userid, $parcel);
    encrypt($userid, $parcel, $version, $keyroot);
}
elsif ($command eq "decrypt") {
    $keyroot = getkeyroot($userid, $parcel);
    decrypt($userid, $parcel, $version, $keyroot);
}
elsif ($command eq "keygen") {
    $result = keygen(KEYROOT_BYTES);
    print "$result\n";
}
elsif ($command eq "getkeyroot") {
    $result = getkeyroot($userid, $parcel);
    print "$result\n";
}
elsif ($command eq "adduser") {
    adduser($userid);
}
elsif ($command eq "deluser") {
    deluser($userid);
}
elsif ($command eq "copyparcel") {
    copyparcel($userid, $parcel, $srcuserid, $srcparcel, $size);
}
elsif ($command eq "makeparcel") {
    makeparcel($userid, $parcel, $size, $memsize, $vmm);
}
elsif ($command eq "delparcel") {
    delparcel($userid, $parcel);
}
elsif ($command eq "prune") {
    prune($userid, $parcel, $retain);
}
elsif ($command eq "getusage") {
    getusage();
}
else {
    usage("$command is an invalid command.");
}
exit 0;


####################################
# Section 2: Definitions of commands
####################################
#
# prune - Prune all but the last "retain" versions of a parcel
#
sub prune ($$$) {
    my $userid = shift;
    my $parcel = shift;
    my $retain = shift; 

    my $parceldir;
    my @files;
    my $firstver;
    my $lastver;
    my $lastvertoprune;
    my $i;
    my $dirpath;
    my $dirname;
    my $reply;

    $parceldir = "$config{content_root}/$userid/$parcel";
    
    # Not allowed to prune all of the versions!
    if ($retain < 1) {
	errexit("You must retain at least one version when pruning.");
    }

    # Get the list of versions
    opendir(DIR, $parceldir)
	or unix_errexit("Could not open directory $parceldir");
    @files = grep(/^\d+$/, readdir(DIR));
    closedir(DIR);


    # Determine the first, last, and last version to prune
    @files = reverse sort @files;
    $lastver = int($files[0]);
    $lastvertoprune = $lastver - $retain;

    @files = sort @files;
    $firstver = int($files[0]);


    # There may not be anything to do
    if ($lastvertoprune < $firstver) {
	print "No files pruned.\n";
	return;
    }

    # Prune versions $firstver to $lastver - $retain
    $reply = query("Deleting versions $firstver to $lastvertoprune. Proceed?");
    if ($reply eq "y") {
	for ($i = $firstver; $i <= $lastvertoprune; $i++) {
	    $dirname = sprintf("%06d", $i);
	    $dirpath = "$parceldir/$dirname";
	    print "Deleting $dirpath...\n";
	    system("rm -rf $dirpath") == 0
		or system_errexit("Unable to delete $dirpath.");
	}
    }
}

#
# encrypt - Encrypts an unencrypted parcel
#
sub encrypt ($$$$) {
    my $userid = shift;
    my $parcel = shift;
    my $version = shift;
    my $keyroot = shift;

    my $versionname = sprintf("%06d", $version);
    my $parceldir = "$config{content_root}/$userid/$parcel/$versionname";
    my $rh;
    my $fd;

    foreach $target ("cfg.tgz", "keyring") {
	print("Encrypting $target.\n")
	    if $verbose;
	if (!-e "$parceldir/$target") {
	    errexit("Missing $parceldir/$target.\n");
	}
	($rh, $fd) = keyroot_pipe($keyroot);
        if (system(LIBDIR . "/blobtool -e -i $parceldir/$target -o $parceldir/$target.enc -k $fd") != 0) {
            system_errexit("Unable to encrypt $parceldir/$target.");
	}
	unlink("$parceldir/$target");
    }
}

#
# decrypt - Decrypts an encrypted parcel
#
sub decrypt ($$$$) {
    my $userid = shift;
    my $parcel = shift;
    my $version = shift;
    my $keyroot = shift;

    my $versionname = sprintf("%06d", $version);
    my $parceldir = "$config{content_root}/$userid/$parcel/$versionname";
    my $rh;
    my $fd;
    my $umask;

    $umask = umask(0077);
    foreach $target ("cfg.tgz", "keyring") {
	print("Decrypting $target.enc.\n")
	    if $verbose;
	if (!-e "$parceldir/$target.enc") {
	    errexit("Missing $parceldir/$target.enc.\n");
	}
	($rh, $fd) = keyroot_pipe($keyroot);
	if (system(LIBDIR . "/blobtool -ed -i $parceldir/$target.enc -o $parceldir/$target -k $fd") != 0) {
            system_errexit("Unable to decrypt $parceldir/$target.");
	}
	unlink("$parceldir/$target.enc");
    }
    umask($umask);
}

#
# keygen - Generate the specified number of random bytes, base64-encoded
#
sub keygen ($) {
    my $bytes = shift;
    
    my $data;
    
    open(UR, "/dev/urandom")
        or unix_errexit("Couldn't open /dev/urandom");
    read(UR, $data, $bytes) == $bytes
        or unix_errexit("Couldn't read /dev/urandom");
    close(UR);
    return encode_base64($data, "");
}

#
# getkeyroot - Return the keyroot for a parcel
#
sub getkeyroot ($$) {
    my $userid = shift;
    my $parcel = shift;

    return get_value(get_parcelcfg_path($userid, $parcel), "KEYROOT");
}

#
# make_userdir - Create the user's base directory in the content root, if it
#                doesn't already exist
#
sub make_userdir ($) {
    my $userid = shift;

    my $userdir = "$config{content_root}/$userid";

    if (!-d $userdir) {
	mkdir($userdir)
	    or unix_errexit("Unable to create user directory ($userdir)");
	system("chown $userid:$userid $userdir") == 0
	    or system_errexit("Unable to set owner of $userdir");
	chmod(0755, $userdir) == 1
	    or unix_errexit("Unable to set permissions on $userdir");
    }
}

#
# adduser - Add a new user
#
sub adduser ($) {
    my $userid = shift;

    my $sshdir = "/home/$userid/.ssh";
    my $isrdir = "/home/$userid/.isr";
    my $passwd;

    # Make sure the account doesn't already exist
    errexit("User $userid exists.")
        if defined getpwnam($userid);

    # Create the user's account 
    print "Adding $userid...\n";
    system("/usr/sbin/useradd -d /home/$userid -m $userid") == 0
	or errexit("Unable to create new account for $userid");

    # Change the password
    $passwd = $config{'default_pass'};
    $passwd = keygen(PASSWORD_BYTES)
        unless defined $passwd;
    open(CHP, '|-', 'chpasswd -m')
        or unix_errexit("Unable to change password for $userid");
    print CHP "$userid:$passwd\n";
    close CHP
	or system_errexit("Unable to change password for $userid");

    # Create data directories
    if (!-d $isrdir) {
	mkdir("$isrdir")
	    or unix_errexit("Unable to make .isr directory for $userid");
    }
    make_userdir($userid);

    # Set the file permissions
    system("chown $userid:$userid $isrdir") == 0
	or errexit("Unable to chown .isr ownership to $userid");
    chmod(0700, "/home/$userid") == 1
    	or unix_errexit("Unable to set /home/$userid permissions to 700");
    chmod(0700, $isrdir) == 1
    	or unix_errexit("Unable to set $isrdir permissions to 700");

    # Add the public and private ssh keys to the user's account
    if (!-d $sshdir) {
	mkdir("$sshdir") 
	    or unix_errexit("Unable to make .ssh directory for $userid");
    }
    system("chown $userid:$userid $sshdir") == 0
	or errexit("Unable to chown .ssh ownership to $userid");
    system("ssh-keygen -C $userid -t rsa -f $sshdir/id_rsa -P ''") == 0
	or errexit("Unable to generate ssh keys for $userid");
    copy("$sshdir/id_rsa.pub", "$sshdir/authorized_keys")
	or unix_errexit("Unable to create authorized_keys file");
    system("chown $userid:$userid $sshdir/id_rsa $sshdir/id_rsa.pub $sshdir/authorized_keys") == 0
	or errexit("Unable to chown key files to $userid");

    print "Success: $userid added to server\n";
    print "Password: $passwd\n";
}

#
# deluser - Delete all traces of an ISR user
#
sub deluser ($) {
    my $userid = shift;

    my $reply;

    #
    # Remove a user's account and everything in their home directory
    #
    $reply = query("Do you really want to delete all files for $userid?");
    if ($reply eq "y") {
	$reply = query("Are you really really sure?");
	if ($reply eq "y") {
	    print "Removing $userid...\n";
	    system("/usr/sbin/userdel -r $userid");
	    system("rm -rf $config{content_root}/$userid");
	} else {
	    print "Did not delete the account for $userid.\n";
	}
    }
}

#
# init_parceldir - Helper to create a new parcel directory
#
sub init_parceldir ($$) {
    my $userid = shift;
    my $parcel = shift;
    
    my $umask;
    
    my $parceldir = "$config{content_root}/$userid/$parcel";
    my $parcelcfg = get_parcelcfg_path($userid, $parcel);
    my $parcelcfgdir = dirname($parcelcfg);
    
    errexit("Parcel $userid/$parcel exists.")
        if -d $parceldir;
    
    # Create new content directory for this user if one doesn't already exist
    make_userdir($userid);

    # Create empty directories for the parcel
    mkdir($parceldir)
	or unix_errexit("Unable to make directory $parceldir.");
    mkdir("$parceldir/cache")
	or unix_errexit("Unable to make directory $parceldir/cache.");
    mkdir("$parceldir/000001")
        or unix_errexit("Can't make parcel version directory");
    mkdir("$parceldir/000001/hdk")
        or unix_errexit("Can't make hdk directory");
    $umask = umask(0077);
    mkdir($parcelcfgdir)
	or unix_errexit("Unable to make directory $parcelcfgdir.");
    umask($umask);
    
    return ($parceldir, $parcelcfg);
}

#
# finalize_parceldir - Helper to finish setting up a newly-created parcel dir
#
sub finalize_parceldir ($$) {
    my $userid = shift;
    my $parcel = shift;
    
    my $parceldir = "$config{content_root}/$userid/$parcel";
    my $parcelcfgdir = dirname(get_parcelcfg_path($userid, $parcel));
    
    # Set the appropriate ownership and permissions for the parceldir,
    # and create the last symlink
    symlink("000001", "$parceldir/last")
        or errexit("Unable to create last symlink");
    system("chown -R $userid:$userid $parceldir") == 0
	or errexit("Unable to set owner of $parceldir");
    system("chmod -R u=rwX,go=rX $parceldir") == 0
	or errexit("Unable to set permissions of $parceldir");
    
    # Set ownership for the parcel.cfg directory
    system("chown -R $userid:$userid $parcelcfgdir") == 0
	or errexit("Unable to set owner of $parcelcfgdir");
}

#
# gen_uuid - Generate a new UUID
#
sub gen_uuid () {
    my $uuid = `uuidgen`;
    $? == 0
	or errexit("Couldn't generate UUID");
    chomp($uuid);
    return $uuid;
}

#
# parse_disk_size - Parse a disk size parameter and return NUMCHUNKS
#
sub parse_disk_size ($$) {
    my $chunksize = shift;
    my $size = shift;

    my $shift;

    unless ($size =~ /^([0-9]+)([KMG])$/) {
	errexit("Can't parse specified parcel size '$size'");
    }
    if ($2 eq "K") {
	$shift = 0;
    } elsif ($2 eq "M") {
	$shift = 10;
    } elsif ($2 eq "G") {
	$shift = 20;
    }
    # Avoid integer overflow on 32-bit systems
    return ceil(($1 << $shift) / ($chunksize >> 10));
}

#
# get_maxkb - Calculate the MAXKB setting for a given CHUNKSIZE and
#             NUMCHUNKS
#
sub get_maxkb ($$) {
    my $chunksize = shift;
    my $numchunks = shift;

    return ($chunksize >> 10) * $numchunks * 2;
}

#
# gen_chunks - Populate a parcel with zeroed chunks
#
sub gen_chunks ($$$$$) {
    my $parcelverdir = shift;
    my $start = shift;
    my $count = shift;
    my $chunksize = shift;
    my $chunksperdir = shift;

    my $blobtool = LIBDIR . "/blobtool";
    my $tmp1 = mktempfile();
    my $tmp2 = mktempfile();
    my $data;
    my $key;
    my $tag;
    my $rh;
    my $fd;
    my $lastdir = "";
    my $dir;
    my $file;
    my $i;

    # Generate a single, zeroed chunk
    open(ZL, "|-", "$blobtool -Zo $tmp1")
        or errexit("Unable to generate zeroed chunk");
    print ZL (pack("c", 0) x $chunksize);
    close ZL
        or errexit("Unable to generate zeroed chunk");
    $key = `$blobtool -hi $tmp1`
        or errexit("Unable to generate key");
    chomp $key;
    ($rh, $fd) = keyroot_pipe(substr($key, 0, 32));
    system("$blobtool -ec -i $tmp1 -o $tmp2 -k $fd") == 0
        or errexit("Unable to encrypt chunk");
    $tag = `$blobtool -hi $tmp2`
        or errexit("Unable to generate tag");
    chomp $tag;
    open(FD, $tmp2)
        or errexit("Unable to read encrypted chunk");
    read(FD, $data, $chunksize)
        or errexit("Unable to read encrypted chunk data");
    close(FD);
    
    # Generate the chunk tree
    for ($i = $start; $i < $start + $count; $i++) {
	$dir = "$parcelverdir/hdk/" . sprintf("%04d", int($i / $chunksperdir));
	$file = "$dir/" . sprintf("%04d", $i % $chunksperdir);
	if ($dir ne $lastdir and ! -d $dir) {
	    mkdir($dir)
		or errexit("Can't create $dir");
	}
	$lastdir = $dir;
	open(FD, ">", $file)
	    or errexit("Can't write $file");
	print FD $data;
	close(FD);
    }
    
    # Populate the keyring
    # zlib is compresstype 2
    system(LIBDIR . "/query $parcelverdir/keyring " .
	            "'INSERT INTO keys (chunk, tag, key, compression) " .
		    "VALUES (?, ?, ?, 2)' -i -b $tag -b $key " .
		    "-r " . $start . ":" . ($start + $count - 1) .
		    " > /dev/null") == 0
        or errexit("Couldn't populate keyring");
}

#
# Copy the specified number of chunks from oldbase to newbase.
#
sub copy_chunks ($$$$) {
    my $oldbase = shift;
    my $newbase = shift;
    my $numchunks = shift;
    my $chunksperdir = shift;

    my $dir;
    my $file;
    my $newdir;
    my $lastdir = "";
    my $i;

    for ($i = 0; $i < $numchunks; $i++) {
	$dir = sprintf("%04d", int($i / $chunksperdir));
	$file = sprintf("%04d", $i % $chunksperdir);
	$newdir = "$newbase/hdk/$dir";
	if ($newdir ne $lastdir and ! -d $newdir) {
	    mkdir($newdir)
		or errexit("Can't create $newdir");
	}
	$lastdir = $newdir;
	copy("$oldbase/hdk/$dir/$file", "$newdir/$file")
	    or unix_errexit("Couldn't write $newdir/$file");
    }
    system(LIBDIR . "/query $newbase/keyring 'DELETE FROM keys WHERE " .
			"chunk >= " . $numchunks . "' > /dev/null") == 0
        or errexit("Couldn't update keyring");
}

#
# copyparcel - Create a new parcel based on an existing one
#             
sub copyparcel ($$$$$) {
    my $userid = shift;      # Destination user id
    my $parcel = shift;      # Destination parcel name
    my $srcuserid = shift;   # Source user id
    my $srcparcel = shift;   # Source parcel name
    my $size = shift;        # New parcel size, if resize desired

    my $dstparcelcfg;
    my $parceldir;
    my $lastver;
    my $srckeyroot;
    my $dstkeyroot;
    my $file;
    my $uuid;
    my $umask;
    my @files;
    my %map;

    my $srcpath = "$config{content_root}/$srcuserid/$srcparcel";
    my $srcparcelcfg = get_parcelcfg_path($srcuserid, $srcparcel);

    my $chunksize = int(get_value($srcparcelcfg, "CHUNKSIZE"));
    my $chunksperdir = int(get_value($srcparcelcfg, "CHUNKSPERDIR"));
    my $srcchunks = int(get_value($srcparcelcfg, "NUMCHUNKS"));
    my $numchunks = $srcchunks;
    my $maxkb = int(get_value($srcparcelcfg, "MAXKB"));
    if (defined $size) {
	$numchunks = parse_disk_size($chunksize, $size);
	$maxkb = get_maxkb($chunksize, $numchunks);
    }

    # Warn user if they asked to reduce the disk size
    print YELLOW, "Warning: Copied parcel has smaller disk than original.\n",
			RESET
	if $srcchunks > $numchunks;

    # Create new content directory for this user and parcel
    ($parceldir, $dstparcelcfg) = init_parceldir($userid, $parcel);

    # Determine the last version that was checked in (note that
    # we can't use the last link because it might not be the
    # same on the nfs server
    opendir(DIR, $srcpath)
	or unix_errexit("Could not open directory $srcpath");
    @files = reverse sort grep(/^\d+$/, readdir(DIR));
    closedir(DIR);
    $lastver = sprintf("%06d", int($files[0]));

    # Copy the parcel metadata and memory image, and decrypt it
    print "Copying $srcpath/$lastver to $parceldir/000001...\n";
    for $file ("cfg.tgz.enc", "keyring.enc") {
        copy("$srcpath/$lastver/$file", "$parceldir/000001/$file")
            or unix_errexit("Couldn't write new $file");
    }
    $srckeyroot = get_value($srcparcelcfg, "KEYROOT");
    decrypt($userid, $parcel, 1, $srckeyroot);

    # Copy the disk to the destination, trimming the keyring if necessary
    copy_chunks("$srcpath/$lastver", "$parceldir/000001",
			$numchunks > $srcchunks ? $srcchunks : $numchunks,
			$chunksperdir);

    # Extend the parcel if requested
    if ($numchunks > $srcchunks) {
        print "Generating new chunks...\n";
        gen_chunks("$parceldir/000001", $srcchunks, $numchunks - $srcchunks,
			$chunksize, $chunksperdir);
    }

    # Re-encrypt the cfg tarball with a new keyroot
    $dstkeyroot = keygen(KEYROOT_BYTES);
    encrypt($userid, $parcel, 1, $dstkeyroot);
    
    # Write out the new parcel.cfg
    $uuid = gen_uuid();
    $umask = umask(0077);
    open(IN, $srcparcelcfg)
    	or unix_errexit("Couldn't read $srcparcelcfg");
    open(OUT, ">", $dstparcelcfg)
    	or unix_errexit("Couldn't write $dstparcelcfg");
    %map = (
        KEYROOT => $dstkeyroot,
        UUID => $uuid,
        USER => $userid,
        PARCEL => $parcel,
        NUMCHUNKS => $numchunks,
        MAXKB => $maxkb
    );
    while (<IN>) {
    	if (/^([[:alpha:]]+)/ and exists $map{$1}) {
	    print OUT "$1 = $map{$1}\n";
	} else {
	    print OUT;
	}
    }
    close IN;
    close OUT;
    umask($umask);
    
    # Set ownership and permissions, add last symlink, etc.
    finalize_parceldir($userid, $parcel);

    print "Success: Added $userid/$parcel\n";
}

#
# new_parcel - Helper to create a new parcel
#
sub new_parcel ($$$$$$$) {
    my $userid = shift;      # Destination user id
    my $parcel = shift;      # Destination parcel name
    my $memsize = shift;     # Memory image size
    my $vmm = shift;         # VMM type
    my $get_size = shift;    # Get-size handler for disk
    my $make_chunks = shift; # Chunk-generation handler for disk
    my $diskinfo = shift;    # Handler-specific information about disk

    my $parcelcfg;
    my $parceldir;
    my $parcelverdir;
    my $keyroot;
    my $uuid;
    my $umask;
    my $numchunks;
    my $maxkb;

    my $chunksize = CHUNKSIZE;
    my $chunksperdir = CHUNKSPERDIR;

    # Calculate parcel size
    $numchunks = $get_size->($chunksize, $diskinfo);
    $maxkb = get_maxkb($chunksize, $numchunks);
    
    # Validate memory image size
    errexit("Invalid memory image size '$memsize'")
        unless $memsize > 0;
    
    # Create new content directory for this user and parcel
    print "Initializing parcel...\n";
    ($parceldir, $parcelcfg) = init_parceldir($userid, $parcel);
    $parcelverdir = "$parceldir/000001";
    
    # Create the keyring
    system(LIBDIR . "/query $parcelverdir/keyring " .
	            "'PRAGMA auto_vacuum = 0; " .
	            "PRAGMA legacy_file_format = ON; " .
		    "PRAGMA user_version = 1; " .
		    "CREATE TABLE keys (" . 
		    "chunk INTEGER PRIMARY KEY NOT NULL, " .
		    "tag BLOB NOT NULL, " .
		    "key BLOB NOT NULL, " .
		    "compression INTEGER NOT NULL); " .
		    "CREATE INDEX keys_tags ON keys (tag)'") == 0
        or errexit("Couldn't create keyring");
    
    # Generate the chunk tree and populate the keyring
    print "Generating virtual disk...\n";
    $make_chunks->($diskinfo, $parcelverdir, $numchunks, $chunksize,
			$chunksperdir);
    
    # Generate the cfg tarball
    print "Populating memory image...\n";
    mkdir("$parcelverdir/cfg")
        or errexit("Couldn't create cfg directory");
    system(LIBDIR . "/blobtool -to $parcelverdir/cfg.tgz -C $parcelverdir cfg") == 0
        or errexit("Couldn't generate cfg tarball");
    rmdir("$parcelverdir/cfg")
	or errexit("Couldn't remove cfg directory");
    
    # Encrypt the parcel with a new keyroot
    print "Encrypting metadata...\n";
    $keyroot = keygen(KEYROOT_BYTES);
    encrypt($userid, $parcel, 1, $keyroot);
    
    # Write out the new parcel.cfg
    print "Finishing...\n";
    $uuid = gen_uuid();
    $umask = umask(0077);
    open(OUT, ">", $parcelcfg)
    	or unix_errexit("Couldn't write $parcelcfg");
    print OUT <<EOF;
VERSION = 3
UUID = $uuid
VMM = $vmm
CRYPTO = aes-sha1
COMPRESS = zlib,lzf
KEYROOT = $keyroot
USER = $userid
PARCEL = $parcel
PROTOCOL = HTTPSSH
SERVER = $config{hostname}
RPATH = http://$config{hostname}$config{http_path}
WPATH = $config{hostname}:$config{content_root}
MAXKB = $maxkb
CHUNKSIZE = $chunksize
NUMCHUNKS = $numchunks
CHUNKSPERDIR = $chunksperdir
MEM = $memsize
EOF
    close OUT;
    umask($umask);

    # Set ownership and permissions, add last symlink, etc.
    finalize_parceldir($userid, $parcel);
    
    print "Success: Added $userid/$parcel\n";
}

#
# makeparcel_gen_chunks - gen_chunks wrapper for makeparcel
#
sub makeparcel_gen_chunks ($$$$$) {
    my $diskinfo = shift;
    my $parcelverdir = shift;
    my $numchunks = shift;
    my $chunksize = shift;
    my $chunksperdir = shift;

    gen_chunks($parcelverdir, 0, $numchunks, $chunksize, $chunksperdir);
}

#
# makeparcel - Create a new, empty parcel
#
sub makeparcel ($$$$$) {
    my $userid = shift;      # Destination user id
    my $parcel = shift;      # Destination parcel name
    my $size = shift;        # Disk size
    my $memsize = shift;     # Memory image size
    my $vmm = shift;         # VMM type

    new_parcel($userid, $parcel, $memsize, $vmm, \&parse_disk_size,
			\&makeparcel_gen_chunks, $size);
}

#
# delparcel - Delete a user's parcel
#
sub delparcel ($$) {
    my $userid = shift;
    my $parcel = shift;

    my $parceldir = "$config{content_root}/$userid/$parcel";
    my $parcelcfg = get_parcelcfg_path($userid, $parcel);
    my $parcelcfgdir = dirname($parcelcfg);
    my $reply;

    errexit("No such parcel $userid/$parcel")
        if ! -d $parcelcfgdir and ! -d $parceldir;
    $reply = query("Do you really want to delete all data for $userid/$parcel?");
    if ($reply eq "y") {
	$reply = query("Are you really really sure?");
	if ($reply eq "y") {
	    print "Removing parcel $userid/$parcel...\n";
	    system("rm -rf $parcelcfgdir") == 0
	        or errexit("Couldn't remove $parcelcfgdir");
	    system("rm -rf $parceldir") == 0
	        or errexit("Couldn't remove $parceldir");
	}
    }
}

#
# getusage - Summarize the recent activity of each user
#
sub getusage () {
    my $userid;
    my $locklog;
    my $logentry;
    my $logdate;
    my $logstatus;
    my $msg;
    
    my @isrusers = ();
    my @parcels;

    # Generate the list of isr users
    opendir(HOMEDIR, "/home")
	or unix_errexit("Couldn't read /home");
    foreach $userid (grep(!/^\./, readdir(HOMEDIR))) {
	push(@isrusers, $userid)
	    if -d "/home/$userid/.isr";
    }
    closedir(HOMEDIR);

    # For each user and parcel, extract the last last entry in the 
    # lockholder log
    foreach $userid (sort @isrusers) {
	opendir(ISRDIR, "/home/$userid/.isr")
	    or unix_errexit("Couldn't read $userid's ISR directory");
	@parcels = sort grep(!/^\./, readdir(ISRDIR));
	foreach $parcel (@parcels) {
	    $locklog = "$config{content_root}/$userid/$parcel/lockholder.log";
	    
	    # Extract the date of the last release or acquire of this parcel
	    ($logdate, $logstatus) = ("Never", "");
	    if (-e $locklog) {
		$logentry = `tail -n 1 $locklog`;
		chomp($logentry);
		($logdate, $logstatus) = (split('\|', $logentry))[1,2]
		    if $logentry;
	    }
	    
	    # Now print the message
	    $msg = sprintf("%-25s $logdate\n", "$userid/$parcel");
	    if ($logstatus eq "released") {
		print GREEN, $msg, RESET;
	    } elsif ($logstatus eq "acquired") {
		print RED, $msg, RESET;
	    } else {
		print $msg;
	    }
	}
	closedir(ISRDIR);
	print "\n"
	    if @parcels;
    }
}


#############################
# Section 3: Helper functions
#############################

#
# query - Ask the user a question and return the reply.  If -f/--force was
#         specified, return "y" without prompting the user.
#
sub query ($) {
    my $question = shift;

    my $reply = "";

    return "y"
	if $force;

    # Keep asking until the user replies either y or n
    while ($reply ne "y" and $reply ne "n") {
	print "$question (y/n): ";
	$reply = <STDIN>;
	chomp($reply);
    }
    return $reply;
}

sub usage {
    my $msg = shift;
    my $progname;
    my $croot;
    
    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s;
    ($croot = $config{content_root}) =~ s:/$::;
    
    if ($msg) {
        print "Error: $msg\n";
    }
    
    print "$progname revision " . RCS_REVISION . "\n";
    print RED, "Usage: $progname cmd [options...]\n", RESET;
    print BLUE, "Commands: adduser, copyparcel, decrypt, delparcel, deluser, encrypt,\n";
    print "          getkeyroot, getusage, keygen, makeparcel, prune.\n", RESET;

    print "  adduser    Add user to system (-u).\n";
    print "  deluser    Delete user from system (-u, [-f]).\n";
    print "  copyparcel Create a parcel based on an existing one (-u, -p, -U, -P, [-s]).\n";
    print "  makeparcel Create an empty parcel from scratch (-u, -p, -m, -s, -M).\n";
    print "  delparcel  Delete parcel from system (-u, -p, [-f]).\n";
    print "  decrypt    Decrypt parcel version (-u, -p, -v).\n";
    print "  encrypt    Encrypt parcel version (-u, -p, -v).\n";
    print "  getkeyroot Show parcel keyroot (-u, -p).\n";
    print "  getusage   List recent activity for each parcel (no args)\n";
    print "  keygen     Generate a keyroot (no args).\n";
    print "  prune      Prune old versions of a parcel (-u, -p, -r, [-f]).\n";

    print "Options:\n";
    print "  -f,--force        Don't ask to confirm dangerous operations.\n";
    print "  -h,--help         Print help message (Try '-hh' for some concrete examples).\n";
    print "  -m,--memsize      Size of the parcel's memory image in MB.\n";
    print "  -M,--vmm          Default VMM for the parcel.\n";
    print "  -p,--parcel       Parcel name (e.g., winxp).\n";
    print "  -P,--srcparcel    Source parcel name.\n";
    print "  -r,--retain       How many of the most recent versions to retain when pruning.\n";
    print "  -s,--size         Size of the parcel's virtual disk (e.g. '256M', '8G')\n";
    print "  -u,--userid       ISR userid.\n";
    print "  -U,--srcuserid    Username of source parcel.\n";
    print "  -v,--version      Version number to encrypt or decrypt.\n";
    print "  -V,--verbose      Increment verbosity level.\n";
    if ($help > 1) {
	print "\n";
	print "Examples:\n"; 
	print RED, "adduser - ", RESET, "Add user bovik to the system\n";
	print BLUE, "# isr_admin adduser -u bovik\n", RESET;
	print "\n";
	print RED, "deluser - ", RESET, "Delete user bovik from the system\n";
	print BLUE, "# isr_admin deluser -u bovik\n", RESET;
	print "\n";
	print RED, "copyparcel - ", RESET, "Create new parcel winxp for existing user bovik in $croot\n";
	print "using latest version of existing parcel in $croot/gold/goldwinxp\n";
	print BLUE, "# isr_admin copyparcel -u bovik -p winxp -U gold -Pgoldwinxp\n", RESET;
	print "\nLikewise, but make the disk of the new parcel 10 GB\n";
	print BLUE, "# isr_admin copyparcel -u bovik -p winxp -U gold -Pgoldwinxp -s 10G\n", RESET;
	print "\n";
	print RED, "makeparcel - ", RESET, "Create empty parcel debian, with 512 MB memory image and 8 GB\n";
	print "disk, using VMware as the VMM, in $croot for existing user bovik\n";
	print BLUE, "# isr_admin makeparcel -u bovik -p debian -m 512 -s 8G -M vmware\n";
	print "\n";
	print RED, "delparcel - ", RESET, "Delete all data for parcel winxp belonging to existing user bovik\n";
	print BLUE, "# isr_admin delparcel -u bovik -p winxp\n";
	print "\n";
	print RED, "decrypt - ", RESET, "Decrypt files in $croot/bovik/winxp/00003\n";
	print BLUE, "# isr_admin decrypt -u bovik -p winxp -v 3\n", RESET;
	print "\n";
	print RED, "encrypt - ", RESET, "Encrypt files in $croot/bovik/winxp/00003\n";
	print BLUE, "# isr_admin encrypt -u bovik -p winxp -v 3\n", RESET;
	print "\n";

	print RED, "getkeyroot - ", RESET, "Show the keyroot for parcel bovik/winxp\n";
	print BLUE, "# isr_admin getkeyroot -u bovik -p winxp\n", RESET;
	print "\n";

	print RED, "getusage - ", RESET, "List recent activity for each parcel\n";
	print BLUE, "# isr_admin getusage\n", RESET;
	print "\n";

	print RED, "keygen - ", RESET, "Generate a random key root\n";
	print BLUE, "# isr_admin keygen\n", RESET;
	print "\n";

	print RED, "prune - ", RESET, "Prune all but the last 10 versions of the parcel stored at\n";
	print "$croot/bovik/winxp.\n";
	print BLUE, "# isr_admin prune -u bovik -p winxp -r 10\n", RESET;
    }
    exit 0;
}
