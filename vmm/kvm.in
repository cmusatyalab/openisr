#!!!PERLPATH!!
#
# kvm - OpenISR (R) VMM driver for the Kernel-based Virtual Machine
#
# Copyright (C) 2008-2009 Carnegie Mellon University
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as published
# by the Free Software Foundation.  A copy of the GNU General Public License
# should have been distributed along with this program in the file
# LICENSE.GPL.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

BEGIN {
	do "!!SHAREDIR!!/vmm.pm";
	die "Couldn't load vmm.pm: $!\n"
		if $!;
	die "Couldn't parse vmm.pm: $@\n"
		if $@;
	import vmm;
}

use POSIX;
use IO::Socket::UNIX;
use Term::ANSIColor qw/:constants/;
use strict;
use warnings;

my $program;
my $incoming_method;

# Make sure the specified program is some variety of qemu with KVM support,
# and set global variables defining how to interact with it.  (Different
# versions of qemu expose slightly different interfaces.)  Returns true if
# this program is acceptable.
sub validate_kvm {
	my $prog = shift;
	my $help;
	local $/;

	open(PROG, "-|", "$prog -h")
		or fail "Couldn't execute $prog";
	$help = <PROG>;
	close PROG;
	return 0
		unless $help =~ /-no-kvm/;
	if ($help =~ m/QEMU PC emulator version .* \(kvm-([0-9]+)\)/) {
		# KVM >= 56
		if ($1 < 78) {
			$incoming_method = "file";
			# file or exec will work for outgoing, so we use exec
			# for consistency
		} elsif ($1 < 80) {
			# The only available migrate method is "tcp"
			return 0;
		} else {
			$incoming_method = "exec";
			# Outgoing method must be exec
		}
	} else {
		# Old KVM (< 56) that doesn't give its version in the help
		# string.  Not worth supporting.
		return 0;
	}
	return 1;
}

sub check_runnable {
	fail "Cannot resume: parcel already suspended with $SUSPENDED"
		if $SUSPENDED ne "no" and $SUSPENDED ne "kvm";
	if (defined $COMMAND) {
		fail "$COMMAND invalid or not executable"
			unless defined ($program = find_program $COMMAND);
		fail "$program is not a supported version of KVM"
			unless validate_kvm $program;
	} else {
		# Debian packages call the program "kvm".  Fedora calls it
		# "qemu-kvm".  Source installs call it "qemu-system-x86_64",
		# but so does vanilla qemu, so we have to check for KVM
		# support.
		foreach my $prog ('kvm', 'qemu-kvm', 'qemu-system-x86_64') {
			$program = find_program $prog;
			last if defined $program and validate_kvm $program;
			undef $program;
		}
		fail "Could not find a supported version of KVM"
			unless defined $program;
	}
}

sub get_config {
	my $file = "$CFGDIR/kvm.cfg";
	my $conf = "";
	my $default;

	if (! -e $file) {
		($default = <<EOF) =~ s/^\s+//gm;
			-net nic
			-net user
			-soundhw all
			-serial none
			-parallel none
			-usb
			-usbdevice tablet
			-no-quit
EOF
		open(KCONF, ">", $file)
			or fail "Couldn't write $file";
		print KCONF $default;
		close KCONF;
	}

	open(KCONF, $file)
		or fail "Couldn't read $file";
	while (<KCONF>) {
		next if /^\s*#/;
		chomp;
		$conf .= " $_";
	}
	close KCONF;
	return $conf;
}

sub info {
	$VMNAME = "KVM";
	check_runnable;
}

# Variant of fail() for use by a forked child, which should not be writing
# key-value pairs to stdout (as happens when vmm::main() catches "die")
sub fail_child {
	my $msg = shift;

	print STDERR "$msg\n";
	exit 255;
}

sub send_cmd {
	my $sock = shift;
	my $cmd = shift;
	my $buf = '';
	my $ret;

	# Wait for prompt indicating that the previous command has completed.
	# If we don't do this, "quit" may be processed before "migrate" has
	# finished and we'll end up with an incomplete memory image.
	do {
		sysread($sock, $ret, 32)
			or return;
		$buf .= $ret;
	} while $buf !~ /\(qemu\)/;
	# Send command
	print $sock "$cmd\n";
}

sub run {
	my $ret;
	my $opts;
	my $pid;
	my $rdmask;
	my $piperd;
	my $pipewr;
	my $lsock;
	my $sock;
	my $buf;
	my $sockpath = "$CFGDIR/kvm.ctl";
	my $loadmem = 0;

	check_runnable;

	# First, some housecleaning
	unlink("$CFGDIR/kvm.mem.old", $sockpath);

	# Calculate command-line options
	$opts  = "-name \"$NAME\" -hda $DISK -m $MEM";
	$opts .= " -monitor unix:$sockpath";
	$opts .= get_config;
	$opts .= " -full-screen"
		if $FULLSCREEN eq "yes";
	if ($SUSPENDED eq "kvm" and -e "$CFGDIR/kvm.mem") {
		if ($incoming_method eq "exec") {
			$opts .= " -incoming \"exec:cat $CFGDIR/kvm.mem.old\"";
		} elsif ($incoming_method eq "file") {
			$opts .= " -incoming \"file://$CFGDIR/kvm.mem.old\"";
		} else {
			fail "Unknown incoming_method";
		}
		$loadmem = 1;
	}

	# Set up file descriptors
	$lsock = IO::Socket::UNIX->new(
			Local => $sockpath,
			Listen => 16
		) or fail "Couldn't create listening socket";
	pipe($piperd, $pipewr)
		or fail "Couldn't create signal pipe";

	# Commit to using the memory image.  Failures after this point will
	# invalidate the memory image.
	$SUSPENDED = "no";
	rename("$CFGDIR/kvm.mem", "$CFGDIR/kvm.mem.old")
		if $loadmem;

	# Fork, and run KVM in the child
	local $SIG{'CHLD'} = sub {syswrite($pipewr, 'C')};
	$pid = fork;
	fail "Couldn't fork"
		unless defined $pid;
	if (!$pid) {
		# KVM apparently installs a SIGINT handler, so we have to
		# block SIGINT rather than ignoring it
		sigprocmask(SIG_BLOCK, POSIX::SigSet->new(SIGINT))
			or fail_child "Couldn't block SIGINT";
		# Make sure we don't interfere with the key-value pairs on
		# the parent's stdout
		open(STDOUT, ">&", *STDERR)
			or fail_child "Couldn't reopen stdout";
		exec("$program $opts")
			or fail_child "Couldn't exec $program";
	}

	# Wait for the Unix socket connection to arrive from KVM, or for KVM
	# to die.
	$rdmask = '';
	vec($rdmask, fileno $piperd, 1) = 1;
	vec($rdmask, fileno $lsock, 1) = 1;
	select($rdmask, undef, undef, undef);
	unlink $sockpath;
	if (vec($rdmask, fileno $piperd, 1)) {
		# Child exited
		close $lsock;
		goto 'out';
	}
	if (vec($rdmask, fileno $lsock, 1)) {
		# Connection on listening socket
		$sock = $lsock->accept
			or fail "Couldn't accept socket connection";
		close $lsock;
	}

	# Resume virtual machine if we loaded a memory image
	send_cmd $sock, "cont"
		if $loadmem;

	# Wait for KVM to die or the user to request suspend
	local $SIG{'INT'} = sub {syswrite($pipewr, 'I')};
	print STDERR YELLOW, "Hit Ctrl-C to suspend your parcel.\n", RESET;
	# For some reason Perl is squashing the EINTR error code, so on
	# interrupt we get an undef return with $! set to 0, which is an
	# invalid combination.  Ignore error returns.
	until (sysread($piperd, $buf, 1)) {};
	if ($buf eq "I") {
		# User suspend request
		print STDERR "Suspending parcel...\n";
		send_cmd $sock, "migrate_set_speed 1g";
		send_cmd $sock, "stop";
		send_cmd $sock, "migrate \"exec:dd of=$CFGDIR/kvm.mem " .
					"2>/dev/null\"";
		send_cmd $sock, "quit";
	}
	close $sock;

out:
	# Wait for KVM to exit
	waitpid($pid, 0) == $pid
		or fail "Couldn't obtain exit status of $program";
	$ret = $?;

	# Remove old memory image; determine if we have a new memory image
	unlink "$CFGDIR/kvm.mem.old";
	$SUSPENDED = "kvm"
		if -e "$CFGDIR/kvm.mem";

	# Check KVM exit status
	fail "$program returned $ret"
		if $ret;
}

sub cleanup {
	unlink("$CFGDIR/kvm.mem.old", "$CFGDIR/kvm.ctl");
}

main;
