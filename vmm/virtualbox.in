#!!!PYTHONPATH!!
#
# virtualbox - OpenISR (R) VMM driver for VirtualBox >= 2.0.0
#
# Copyright (C) 2008 Carnegie Mellon University
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as published
# by the Free Software Foundation.  A copy of the GNU General Public License
# should have been distributed along with this program in the file
# LICENSE.GPL.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

import os
import sys
import signal
import shutil
import time
import random
import xml.dom.minidom
sys.path.insert(1, '!!SHAREDIR!!')
import vmm
from vmm import *

CLASS_VBOX = '@virtualbox.org/VirtualBox;1'
CLASS_SESN = '@virtualbox.org/Session;1'
MIN_VERSION = (2,0,0)
SETTINGS_VERSIONS = ((1,3), (1,5))

class MachineFile:
	def __init__(self, vm_path):
		self.path = vm_path
		self.new_path = vm_path + '.new'
		self.dom = xml.dom.minidom.parse(vm_path)

	def descend(self, *elements):
		tbl = self.dom
		for el in elements:
			tbl = tbl.getElementsByTagName(el)
			assert len(tbl) == 1
			tbl = tbl[0]
		return tbl

	def write(self):
		ofd = file(self.new_path, 'w')
		self.dom.writexml(ofd, encoding = 'UTF-8')
		ofd.close()
		os.rename(self.new_path, self.path)

	def close(self):
		"""Must be called when done with the MachineFile to ensure
		that the data structures are properly cleaned up."""
		self.dom.unlink()
		del self.dom

def vbox_init():
	global xpcom, ifaces, vbox

	# Locate the VirtualBox program, then use its location to find the
	# path to the Python bindings library
	if 'COMMAND' in dir(vmm):
		program = find_program(vmm.COMMAND)
		if not program:
			raise VmmError(program + ' invalid or not executable')
	else:
		program = find_program('VirtualBox')
		if not program:
			raise VmmError('VirtualBox not found')
	libdir = '/'.join(os.path.normpath(program).split('/')[:-2]) + \
				'/lib/virtualbox'
	if not os.path.isdir(libdir):
		raise VmmError(libdir + ' does not exist')

	# Load the XPCOM bindings
	sys.path.append(libdir)
	__import__('xpcom.vboxxpcom')
	xpcom = __import__('xpcom')
	xpcom.components = __import__('xpcom.components', None, None, 'xpcom')
	ifaces = xpcom.components.interfaces

	# Get a VirtualBox instance and check the VirtualBox version
	vbox = new_instance(CLASS_VBOX)
	if parse_version(vbox.version) < MIN_VERSION:
		raise VmmError("VirtualBox >= %s required (found %s)" % \
				(format_version(MIN_VERSION), vbox.version))

def parse_version(ver):
	parts = map(int, ver.replace('_OSE', '').split('.'))
	if len(parts) != 3:
		raise VmmError("Couldn't parse version: " + ver)
	return tuple(parts)

def parse_settings_version(ver):
	return tuple(map(int, ver.split('-')[0].split('.')))

def format_version(parts):
	return '.'.join(map(lambda x: str(x), parts))

def new_instance(name):
	return xpcom.components.classes[name].createInstance()

def parcelname():
	return 'openisr-' + vmm.NAME.replace('/', '-')

def handle_signal(sig, frame):
	global signaled
	signaled = True

# Use this from a finally block to ignore exceptions when attempting to close
# a session, so that they do not overwrite any exception that was generated
# in the corresponding try block.
def try_close(sesn):
	try:
		sesn.close()
	except:
		pass

def check_runnable():
	"""Determine whether there are any conditions which would prevent us
	from resuming this machine."""

	# Check that we're suspended with the right VMM
	if vmm.SUSPENDED != 'no' and vmm.SUSPENDED != 'virtualbox':
		raise VmmError('Cannot resume: parcel already suspended ' + \
					'with ' + vmm.SUSPENDED)

	# Check against minimum settings version.  If the settings version
	# is newer than what this VirtualBox can understand, we won't even
	# be able to do an openMachine() to check it, so we have to read
	# the XML.
	want_cfg_ver = parse_settings_version(vbox.settingsFormatVersion)
	mf = MachineFile(vm_path)
	found_cfg_ver = mf.descend('VirtualBox').getAttribute('version')
	found_cfg_ver = parse_settings_version(found_cfg_ver)
	mf.close()
	if want_cfg_ver < found_cfg_ver:
		raise VmmError('VirtualBox too old to run this parcel ' \
					'(settings version %s, max %s)' % \
					(format_version(found_cfg_ver),
					format_version(want_cfg_ver)))

def create_disk():
	# Always round down
	cyls = min(int(vmm.SECTORS) / (16 * 63), 16383)
	bioscyls = min(int(vmm.SECTORS) / (255 * 63), 1024)
	cid = '%x' % random.randint(0, 0xffffffff)

	f = file(disk_path, 'w')
	f.write('''# Disk DescriptorFile
version=1
CID=%s
parentCID=ffffffff
createType="fullDevice"

RW %s FLAT "%s" 0

ddb.geometry.cylinders = "%s"
ddb.geometry.heads = "16"
ddb.geometry.sectors = "63"
ddb.geometry.biosCylinders = "%s"
ddb.geometry.biosHeads = "255"
ddb.geometry.biosSectors = "63"
ddb.adapterType = "ide"
''' % (cid, vmm.SECTORS, vmm.DISK, cyls, bioscyls))
	f.close()

def create_machine():
	vmname = parcelname()
	vm = vbox.createMachine(vmm.CFGDIR, vmname, vmm.UUID)
	vm.memorySize = vmm.MEM
	vm.VRAMSize = 16
	vm.snapshotFolder = '.'
	vm.audioAdapter.enabled = True
	vm.audioAdapter.audioDriver = ifaces.AudioDriverType.ALSA
	try:
		# Not supported with VirtualBox OSE
		vm.USBController.enabled = True
		vm.USBController.enabledEhci = True
	except:
		pass
	net = vm.getNetworkAdapter(0)
	try:
		# Not supported with VirtualBox OSE
		net.adapterType = ifaces.NetworkAdapterType.I82543GC
	except:
		pass
	net.attachToNAT()
	net.enabled = True
	vm.setExtraData('GUI/LastCloseAction', 'save')
	vm.saveSettings()
	del vm
	os.rename('%s/%s/%s.xml' % (vmm.CFGDIR, vmname, vmname), vm_path)
	os.rmdir('%s/%s' % (vmm.CFGDIR, vmname))

def fixup_upgrade_settings(mf):
	"""See if this VM has the most recent settings format.  If not, ask
	the user whether to continue.  Return True if upgrade is required.
	This must run during the first pass rather than the second one:
	otherwise, it could leave a UUID conversion half-done if the user
	decides to abort."""

	cfg_ver = mf.descend('VirtualBox').getAttribute('version')
	if cfg_ver == vbox.settingsFormatVersion:
		return False
	print >>sys.stderr, '\nThis parcel is configured for an older', \
				'version of VirtualBox.'
	print >>sys.stderr, 'If you resume the parcel, it will be upgraded', \
				'and will no longer be usable'
	print >>sys.stderr, 'with older versions of VirtualBox.\n'
	cfg_ver = parse_settings_version(vbox.settingsFormatVersion)
	if cfg_ver not in SETTINGS_VERSIONS:
		print >>sys.stderr, 'NOTE: This version of OpenISR does', \
				'not recognize this version of VirtualBox.'
		print >>sys.stderr, 'Resuming this parcel will likely break', \
				'it.  You may continue anyway, but you'
		print >>sys.stderr, 'should be prepared to "isr discard"', \
				'if it fails.\n'
	resp = ''
	while resp != 'y' and resp != 'n':
		sys.stderr.write('Resume parcel? (y/n) ')
		resp = sys.stdin.readline().strip()
	print >>sys.stderr
	if resp != 'y':
		raise VmmError('User declined to upgrade parcel')
	return True

def fixup_uuid_1(mf):
	"""See if this parcel has been cloned.  If so, we need to update all
	unique identifiers associated with the VM.  If necessary, do the
	by-hand fixups and return True.  If this returns True, the Main API
	fixups need to happen later."""

	new_disk_path = disk_path + '.new'
	uuid = '{' + vmm.UUID + '}'

	# We don't want to openMachine() until we know that the UUID is
	# unique on this system.  The VBox API doesn't provide for updating
	# the UUID, so we have to directly update the XML file.  While we're
	# at it, update the VM name as well.
	mach = mf.descend('VirtualBox', 'Machine')
	if mach.getAttribute('uuid') == uuid:
		return False
	mach.setAttribute('name', unicode(parcelname()))
	mach.setAttribute('uuid', unicode(uuid))

	# Update the path to the Nexus virtual disk, and strip UUIDs from
	# the VMDK so that VBox will regenerate them
	ifd = file(disk_path)
	ofd = file(new_disk_path, 'w')
	for line in ifd:
		if line.startswith('RW '):
			parts = line.split(' ')
			parts[3] = '"' + vmm.DISK + '"'
			ofd.write(' '.join(parts))
		elif line.startswith('ddb.uuid'):
			pass
		else:
			ofd.write(line)
	ifd.close()
	ofd.close()
	os.rename(new_disk_path, disk_path)

	return True

def fixup_uuid_2(vm):
	"""Do Main API fixups to change unique identifiers after a parcel
	has been cloned."""

	# Generate new MAC addresses for the VM's Ethernet cards
	for i in range(vbox.systemProperties.networkAdapterCount):
		vm.getNetworkAdapter(i).MACAddress = None

def fixup_invalid_images(mf):
	"""openMachine() will fail if the machine refers to a disk image that
	does not exist.  Manually check and clean the XML to prevent this.
	Return True if we changed something."""

	modified = False
	hw = mf.descend('VirtualBox', 'Machine', 'Hardware')

	types = ('CD', 'DVDDrive', vbox.getDVDImage), \
		('floppy', 'FloppyDrive', vbox.getFloppyImage)
	for name, el, getFunc in types:
		for drive in hw.getElementsByTagName(el):
			img = drive.getElementsByTagName('Image')
			assert len(img) < 2
			if len(img) == 0:
				continue
			uuid = img[0].getAttribute('uuid')
			try:
				getFunc(str(uuid))
			except:
				print >>sys.stderr, 'Unbinding nonexistent', \
							name, 'image', uuid
				drive.removeChild(img[0])
				modified = True
	return modified

def fixup_inaccessible_devices(vm):
	"""Unbind inaccessible devices which will prevent the VM from starting.
	Return True if we have done so."""

	modified = False
	types = ('CD', vm.DVDDrive), \
		('floppy', vm.FloppyDrive)
	for name, drive in types:
		if drive.state == ifaces.DriveState.ImageMounted:
			image = drive.getImage()
			if not image.accessible:
				print >>sys.stderr, \
					'Unbinding inaccessible', name, \
							'image', image.filePath
				drive.unmount()
				modified = True
		elif drive.state == ifaces.DriveState.HostDriveCaptured:
			path = drive.getHostDrive().name
			if not os.access(path, os.R_OK):
				print >>sys.stderr, \
					'Unbinding inaccessible host', name, \
					'drive', path
				drive.unmount()
				modified = True
	return modified

def fixup_machine():
	"""Fix the machine configuration prior to running it."""

	# First do the fixups that modify the machine files directly, since
	# otherwise openMachine() may fail.
	mf = MachineFile(vm_path)
	# NOTE: fixup_upgrade_settings() runs during the first pass but
	# commits during the second one!
	did_upgrade = fixup_upgrade_settings(mf)
	did_uuid = fixup_uuid_1(mf)
	did_invalid = fixup_invalid_images(mf)
	if did_uuid or did_invalid:
		mf.write()
	mf.close()

	# Now do the fixups that use the Main API.
	vm = vbox.openMachine(vm_path)
	if did_uuid:
		fixup_uuid_2(vm)
	did_inaccessible = fixup_inaccessible_devices(vm)
	if did_uuid or did_inaccessible or did_upgrade:
		vm.saveSettingsWithBackup()

def register_machine():
	disk = vbox.openHardDisk(disk_path)
	vm = vbox.openMachine(vm_path)
	vbox.registerHardDisk(disk)
	vbox.registerMachine(vm)
	sesn = new_instance(CLASS_SESN)
	vbox.openSession(sesn, vm.id)
	try:
		sesn.machine.attachHardDisk(disk.id, ifaces.StorageBus.IDE, \
					0, 0)
		if vmm.FULLSCREEN == 'yes':
			fullscreen = 'on'
		else:
			fullscreen = 'off'
		sesn.machine.setExtraData('GUI/Fullscreen', fullscreen)
		sesn.machine.saveSettings()
		if os.path.isfile(saved_path):
			sesn.console.adoptSavedState(saved_path)
	finally:
		try_close(sesn)

def unregister_state(sesn, do_save):
	have_state = (sesn.machine.state == ifaces.MachineState.Saved)
	if do_save and have_state:
		# The stateFilePath may be equal to the saved_path if the VM
		# was never started successfully, so we rename through a
		# temporary file
		temp_path = saved_path + '.temp'
		os.rename(sesn.machine.stateFilePath, temp_path)
		sesn.console.discardSavedState()
		os.rename(temp_path, saved_path)
		vmm.SUSPENDED = 'virtualbox'
	else:
		if have_state:
			sesn.console.discardSavedState()
		vmm.SUSPENDED = 'no'

def detach_disk(sesn):
	try:
		sesn.machine.getHardDisk(ifaces.StorageBus.IDE, 0, 0)
	except:
		pass
	else:
		sesn.machine.detachHardDisk(ifaces.StorageBus.IDE, 0, 0)
		sesn.machine.saveSettings()

def unregister_machine(do_save = True):
	try:
		vm = vbox.getMachine(vmm.UUID)
	except:
		pass
	else:
		sesn = new_instance(CLASS_SESN)
		vbox.openSession(sesn, vm.id)
		try:
			unregister_state(sesn, do_save)
			detach_disk(sesn)
		finally:
			try_close(sesn)
		vbox.unregisterMachine(vm.id)

	try:
		disk = vbox.findHardDisk(disk_path)
	except:
		pass
	else:
		vbox.unregisterHardDisk(disk.id)

def run_machine():
	global signaled

	sesn = new_instance(CLASS_SESN)
	vmm.SUSPENDED = 'virtualbox'
	progress = vbox.openRemoteSession(sesn, vmm.UUID, 'gui', None)
	progress.waitForCompletion(-1)
	# It would be better to use IVirtualBoxCallback to wait for a
	# session state change, but it's not clear how to do that from Python.
	# We could loop reading sesn.state, but that deadlocks at session
	# shutdown.  So we loop reading vm.sessionState.  Note that the
	# remote session automatically closes once the direct session closes,
	# so we don't need to do it ourselves.
	vm = vbox.getMachine(vmm.UUID)
	while vm.sessionState != ifaces.SessionState.Closed:
		if signaled:
			signaled = False
			print >>sys.stderr, 'Suspending parcel...',
			try:
				progress = sesn.console.saveState()
				progress.waitForCompletion(-1)
			except:
				print >>sys.stderr, 'failed'
			else:
				print >>sys.stderr, 'done'
		time.sleep(0.5)

def info():
	vmm.VMNAME = 'VirtualBox'
	vbox_init()
	check_runnable()

def run():
	signal.signal(signal.SIGINT, handle_signal)
	vbox_init()
	check_runnable()
	if not os.path.isfile(disk_path):
		create_disk()
	if not os.path.isfile(vm_path):
		create_machine()
	fixup_machine()
	# Make sure there's not a leftover registration from a previous crash
	unregister_machine()
	success = False
	try:
		register_machine()
		run_machine()
		success = True
	finally:
		# Make sure unregister exceptions don't clobber an exception
		# raised in the try block, since the latter is more important
		try:
			unregister_machine()
		except:
			if success:
				raise

def cleanup():
	shutil.rmtree(vmm.CFGDIR + '/Logs', True)
	try:
		vbox_init()
	except:
		# Fail silently if VirtualBox isn't installed
		return
	unregister_machine(do_save = False)

vmm.DEBUG = (vmm.VERBOSE == "yes")
vm_path = vmm.CFGDIR + '/virtualbox.xml'
disk_path = vmm.CFGDIR + '/virtualbox.vmdk'
saved_path = vmm.CFGDIR + '/virtualbox.sav'
signaled = False
main()
