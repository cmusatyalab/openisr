#!!!PYTHONPATH!!
#
# virtualbox - OpenISR (R) VMM driver for VirtualBox >= 2.0.0
#
# Copyright (C) 2008 Carnegie Mellon University
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as published
# by the Free Software Foundation.  A copy of the GNU General Public License
# should have been distributed along with this program in the file
# LICENSE.GPL.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

import os
import sys
import signal
import shutil
import time
import random
import xml.dom.minidom
sys.path.insert(1, '!!SHAREDIR!!')
import vmm
from vmm import *

CLASS_VBOX = '@virtualbox.org/VirtualBox;1'
CLASS_SESN = '@virtualbox.org/Session;1'
MIN_VERSION = '2.0.0'

def vbox_init():
	global xpcom, ifaces, vbox

	# Locate the VirtualBox program, then use its location to find the
	# path to the Python bindings library
	if 'COMMAND' in dir(vmm):
		program = find_program(vmm.COMMAND)
		if not program:
			raise VmmError(program + ' invalid or not executable')
	else:
		program = find_program('VirtualBox')
		if not program:
			raise VmmError('VirtualBox not found')
	libdir = '/'.join(os.path.normpath(program).split('/')[:-2]) + \
				'/lib/virtualbox'
	if not os.path.isdir(libdir):
		raise VmmError(libdir + ' does not exist')

	# Load the XPCOM bindings
	sys.path.append(libdir)
	__import__('xpcom.vboxxpcom')
	xpcom = __import__('xpcom')
	xpcom.components = __import__('xpcom.components', None, None, 'xpcom')
	ifaces = xpcom.components.interfaces

	# Get a VirtualBox instance and check the VirtualBox version
	vbox = new_instance(CLASS_VBOX)
	if version_to_int(vbox.version) < version_to_int(MIN_VERSION):
		raise VmmError("VirtualBox >= %s required (found %s)" % \
				(MIN_VERSION, vbox.version))

def version_to_int(ver):
	parts = map(int, ver.split('.'))
	if len(parts) != 3:
		raise VmmError("Couldn't parse version: " + ver)
	return parts[0] * 10000 + parts[1] * 100 + parts[2]

def new_instance(name):
	return xpcom.components.classes[name].createInstance()

def parcelname():
	return 'openisr-' + vmm.NAME.replace('/', '-')

def handle_signal(sig, frame):
	global signaled
	signaled = True

# Use this from a finally block to ignore exceptions when attempting to close
# a session, so that they do not overwrite any exception that was generated
# in the corresponding try block.
def try_close(sesn):
	try:
		sesn.close()
	except:
		pass

def check_runnable():
	if vmm.SUSPENDED != 'no' and vmm.SUSPENDED != 'virtualbox':
		raise VmmError('Cannot resume: parcel already suspended ' + \
					'with ' + vmm.SUSPENDED)

def create_disk():
	# Always round down
	cyls = min(int(vmm.SECTORS) / (16 * 63), 16383)
	bioscyls = min(int(vmm.SECTORS) / (255 * 63), 1024)
	cid = '%x' % random.randint(0, 0xffffffff)

	f = file(disk_path, 'w')
	f.write('''# Disk DescriptorFile
version=1
CID=%s
parentCID=ffffffff
createType="fullDevice"

RW %s FLAT "%s" 0

ddb.geometry.cylinders = "%s"
ddb.geometry.heads = "16"
ddb.geometry.sectors = "63"
ddb.geometry.biosCylinders = "%s"
ddb.geometry.biosHeads = "255"
ddb.geometry.biosSectors = "63"
ddb.adapterType = "ide"
''' % (cid, vmm.SECTORS, vmm.DISK, cyls, bioscyls))
	f.close()

def create_machine():
	vmname = parcelname()
	vm = vbox.createMachine(vmm.CFGDIR, vmname, vmm.UUID)
	vm.memorySize = vmm.MEM
	vm.VRAMSize = 16
	vm.snapshotFolder = '.'
	vm.audioAdapter.enabled = True
	vm.audioAdapter.audioDriver = ifaces.AudioDriverType.ALSA
	if vm.USBController != None:
		vm.USBController.enabled = True
		vm.USBController.enabledEhci = True
	net = vm.getNetworkAdapter(0)
	net.adapterType = ifaces.NetworkAdapterType.I82543GC
	net.attachToNAT()
	net.enabled = True
	vm.setExtraData('GUI/LastCloseAction', 'save')
	vm.saveSettings()
	del vm
	os.rename('%s/%s/%s.xml' % (vmm.CFGDIR, vmname, vmname), vm_path)
	os.rmdir('%s/%s' % (vmm.CFGDIR, vmname))

# See if this parcel has been cloned.  If so, update all unique identifiers
# associated with the VM.
def update_uuid():
	new_vm_path = vm_path + '.new'
	new_disk_path = disk_path + '.new'
	uuid = '{' + vmm.UUID + '}'

	# We don't want to openMachine() until we know that the UUID is
	# unique on this system.  The VBox API doesn't provide for updating
	# the UUID, so we have to directly update the XML file.  While we're
	# at it, update the VM name as well.
	dom = xml.dom.minidom.parse(vm_path)
	vbs = dom.getElementsByTagName('VirtualBox')
	assert len(vbs) == 1
	machs = vbs[0].getElementsByTagName('Machine')
	assert len(machs) == 1
	if machs[0].getAttribute('uuid') == uuid:
		dom.unlink()
		return
	machs[0].setAttribute('name', unicode(parcelname()))
	machs[0].setAttribute('uuid', unicode(uuid))
	ofd = file(new_vm_path, 'w')
	dom.writexml(ofd, encoding = 'UTF-8')
	ofd.close()
	os.rename(new_vm_path, vm_path)
	dom.unlink()

	# Generate new MAC addresses for the VM's Ethernet cards
	vm = vbox.openMachine(vm_path)
	for i in range(vbox.systemProperties.networkAdapterCount):
		vm.getNetworkAdapter(i).MACAddress = None
	vm.saveSettings()

	# Update the path to the Nexus virtual disk, and strip UUIDs from
	# the VMDK so that VBox will regenerate them
	ifd = file(disk_path)
	ofd = file(new_disk_path, 'w')
	for line in ifd:
		if line.startswith('RW '):
			parts = line.split(' ')
			parts[3] = '"' + vmm.DISK + '"'
			ofd.write(' '.join(parts))
		elif line.startswith('ddb.uuid'):
			pass
		else:
			ofd.write(line)
	ifd.close()
	ofd.close()
	os.rename(new_disk_path, disk_path)

def register_machine():
	disk = vbox.openHardDisk(disk_path)
	vm = vbox.openMachine(vm_path)
	vbox.registerHardDisk(disk)
	vbox.registerMachine(vm)
	sesn = new_instance(CLASS_SESN)
	vbox.openSession(sesn, vm.id)
	try:
		sesn.machine.attachHardDisk(disk.id, ifaces.StorageBus.IDE, \
					0, 0)
		if vmm.FULLSCREEN == 'yes':
			fullscreen = 'on'
		else:
			fullscreen = 'off'
		sesn.machine.setExtraData('GUI/Fullscreen', fullscreen)
		sesn.machine.saveSettings()
		if os.path.isfile(saved_path):
			sesn.console.adoptSavedState(saved_path)
	finally:
		try_close(sesn)

def unregister_state(sesn, do_save):
	have_state = (sesn.machine.state == ifaces.MachineState.Saved)
	if do_save and have_state:
		# The stateFilePath may be equal to the saved_path if the VM
		# was never started successfully, so we rename through a
		# temporary file
		temp_path = saved_path + '.temp'
		os.rename(sesn.machine.stateFilePath, temp_path)
		sesn.console.discardSavedState()
		os.rename(temp_path, saved_path)
		vmm.SUSPENDED = 'virtualbox'
	else:
		if have_state:
			sesn.console.discardSavedState()
		vmm.SUSPENDED = 'no'

def detach_disk(sesn):
	try:
		sesn.machine.getHardDisk(ifaces.StorageBus.IDE, 0, 0)
	except:
		pass
	else:
		sesn.machine.detachHardDisk(ifaces.StorageBus.IDE, 0, 0)
		sesn.machine.saveSettings()

def unregister_machine(do_save = True):
	try:
		vm = vbox.getMachine(vmm.UUID)
	except:
		pass
	else:
		sesn = new_instance(CLASS_SESN)
		vbox.openSession(sesn, vm.id)
		try:
			unregister_state(sesn, do_save)
			detach_disk(sesn)
		finally:
			try_close(sesn)
		vbox.unregisterMachine(vm.id)

	try:
		disk = vbox.findHardDisk(disk_path)
	except:
		pass
	else:
		vbox.unregisterHardDisk(disk.id)

def run_machine():
	global signaled

	sesn = new_instance(CLASS_SESN)
	vmm.SUSPENDED = 'virtualbox'
	progress = vbox.openRemoteSession(sesn, vmm.UUID, 'gui', None)
	progress.waitForCompletion(-1)
	# It would be better to use IVirtualBoxCallback to wait for a
	# session state change, but it's not clear how to do that from Python.
	# We could loop reading sesn.state, but that deadlocks at session
	# shutdown.  So we loop reading vm.sessionState.  Note that the
	# remote session automatically closes once the direct session closes,
	# so we don't need to do it ourselves.
	vm = vbox.getMachine(vmm.UUID)
	while vm.sessionState != ifaces.SessionState.Closed:
		if signaled:
			signaled = False
			print >>sys.stderr, 'Suspending parcel...',
			try:
				progress = sesn.console.saveState()
				progress.waitForCompletion(-1)
			except:
				print >>sys.stderr, 'failed'
			else:
				print >>sys.stderr, 'done'
		time.sleep(0.5)

def info():
	vmm.VMNAME = 'VirtualBox'
	check_runnable()
	# We don't actually need XPCOM, but we have to make sure that we can
	# load it successfully
	vbox_init()

def run():
	signal.signal(signal.SIGINT, handle_signal)
	check_runnable()
	vbox_init()
	if not os.path.isfile(disk_path):
		create_disk()
	if not os.path.isfile(vm_path):
		create_machine()
	update_uuid()
	# Make sure there's not a leftover registration from a previous crash
	unregister_machine()
	success = False
	try:
		register_machine()
		run_machine()
		success = True
	finally:
		# Make sure unregister exceptions don't clobber an exception
		# raised in the try block, since the latter is more important
		try:
			unregister_machine()
		except:
			if success:
				raise

def cleanup():
	shutil.rmtree(vmm.CFGDIR + '/Logs', True)
	try:
		vbox_init()
	except:
		# Fail silently if VirtualBox isn't installed
		return
	unregister_machine(do_save = False)

vmm.DEBUG = (vmm.VERBOSE == "yes")
vm_path = vmm.CFGDIR + '/virtualbox.xml'
disk_path = vmm.CFGDIR + '/virtualbox.vmdk'
saved_path = vmm.CFGDIR + '/virtualbox.sav'
signaled = False
main()
