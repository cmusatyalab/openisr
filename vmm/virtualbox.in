#!!!PYTHONPATH!!
#
# virtualbox - OpenISR (R) VMM driver for VirtualBox >= 2.0.0
#
# Copyright (C) 2008-2009 Carnegie Mellon University
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as published
# by the Free Software Foundation.  A copy of the GNU General Public License
# should have been distributed along with this program in the file
# LICENSE.GPL.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

import os
import sys
import signal
import shutil
import time
import random
import xml.dom.minidom
sys.path.insert(1, '!!SHAREDIR!!')
import vmm
from vmm import *

CLASS_VBOX = '@virtualbox.org/VirtualBox;1'
CLASS_SESN = '@virtualbox.org/Session;1'
MIN_VERSION = (2,0,0)
SETTINGS_VERSIONS = ((1,3), (1,5), (1,6), (1,7))

class MachineFile:
	def __init__(self, vm_path):
		self.path = vm_path
		self.new_path = vm_path + '.new'
		self.dom = xml.dom.minidom.parse(vm_path)

	def descend(self, *elements):
		tbl = self.dom
		for el in elements:
			tbl = tbl.getElementsByTagName(el)
			assert len(tbl) == 1
			tbl = tbl[0]
		return tbl

	def write(self):
		ofd = file(self.new_path, 'w')
		self.dom.writexml(ofd, encoding = 'UTF-8')
		ofd.close()
		os.rename(self.new_path, self.path)

	def close(self):
		"""Must be called when done with the MachineFile to ensure
		that the data structures are properly cleaned up."""
		self.dom.unlink()
		del self.dom

class VboxCompat:
	def __init__(self):
		parts = map(int, vbox.version.replace('_OSE', '').split('.'))
		if len(parts) != 3:
			raise VmmError("Couldn't parse VirtualBox version: " \
						+ vbox.version)
		self.vbox_ver = tuple(parts)
		if self.vbox_ver < MIN_VERSION:
			raise VmmError("VirtualBox >= %s required (found %s)" \
					% (format_version(MIN_VERSION), \
					vbox.version))

	def create_machine(self, vmdir, name, uuid):
		'''Create a machine, configure it to disable VT support, and
		return it.'''
		if self.vbox_ver < (2,1):
			vm = vbox.createMachine(vmdir, name, uuid)
		else:
			vm = vbox.createMachine(name, 'Other', vmdir, uuid)

		if self.vbox_ver < (3,0,2):
			vm.HWVirtExEnabled = ifaces.TSBool.False
		else:
			vm.HWVirtExEnabled = False

		return vm

	def register_disk(self, path):
		'''Register the disk at the specified path and return it.'''
		if self.vbox_ver < (2,1):
			disk = vbox.openHardDisk(path)
			vbox.registerHardDisk(disk)
			return disk
		elif self.vbox_ver < (2,2):
			return vbox.openHardDisk2(path)
		elif self.vbox_ver < (3,0):
			return vbox.openHardDisk(path, \
					ifaces.AccessMode.ReadWrite)
		else:
			return vbox.openHardDisk(path, \
					ifaces.AccessMode.ReadWrite, \
					False, '', False, '')

	def unregister_disk(self, path):
		'''Unregister the disk at the specified path if it exists.'''
		try:
			if self.vbox_ver >= (2,1) and self.vbox_ver < (2,2):
				disk = vbox.findHardDisk2(path)
			else:
				disk = vbox.findHardDisk(path)
		except:
			return
		else:
			if self.vbox_ver < (2,1):
				vbox.unregisterHardDisk(disk.id)
			else:
				disk.close()

	def __find_ide_controller(self, sesn_machine):
		for ctlr in sesn_machine.getStorageControllers():
			if ctlr.bus == ifaces.StorageBus.IDE:
				return ctlr
		raise VmmError("Couldn't find an IDE controller")

	def attach_ide_disk(self, sesn_machine, uuid, port, device):
		'''Attach the specified disk to the given machine's IDE
		controller.  The machine handle must be obtained from an open
		session.'''
		if self.vbox_ver < (2,2):
			ctlr = ifaces.StorageBus.IDE
		else:
			ctlr = self.__find_ide_controller(sesn_machine).name
		if self.vbox_ver >= (2,1) and self.vbox_ver < (2,2):
			sesn_machine.attachHardDisk2(uuid, ctlr, port, device)
		else:
			sesn_machine.attachHardDisk(uuid, ctlr, port, device)

	def detach_ide_disk(self, sesn_machine, port, device):
		'''Detach the specified disk from the given machine's IDE
		controller, if such an attachment exists.  Save machine
		settings if successful.  The machine handle must be obtained
		from an open session.'''
		try:
			if self.vbox_ver < (2,2):
				ctlr = ifaces.StorageBus.IDE
			else:
				ctlr = self.__find_ide_controller( \
						sesn_machine).name
			if self.vbox_ver >= (2,1) and self.vbox_ver < (2,2):
				sesn_machine.getHardDisk2(ctlr, port, device)
			else:
				sesn_machine.getHardDisk(ctlr, port, device)
		except:
			pass
		else:
			if self.vbox_ver >= (2,1) and self.vbox_ver < (2,2):
				sesn_machine.detachHardDisk2(ctlr, port, device)
			else:
				sesn_machine.detachHardDisk(ctlr, port, device)
			sesn_machine.saveSettings()

	def release_saved_state(self, sesn, dest_path = None):
		'''Unregister the saved state attached to the given session.
		If dest_path is specified, move the state file to that
		location, otherwise remove it.'''
		if dest_path is not None:
			if self.vbox_ver < (3,0):
				# The stateFilePath may be equal to the
				# dest_path (if the VM was never started
				# successfully), so we rename through a
				# temporary file
				cur_path = dest_path + '.temp'
				os.rename(sesn.machine.stateFilePath, cur_path)
				sesn.console.discardSavedState()
			else:
				cur_path = sesn.machine.stateFilePath
				sesn.console.forgetSavedState(False)
			os.rename(cur_path, dest_path)
		else:
			if self.vbox_ver < (3.0):
				sesn.console.discardSavedState()
			else:
				sesn.console.forgetSavedState(True)

	def get_floppy_drive(self, vm):
		'''Return the floppy drive object for the specified machine.'''
		if self.vbox_ver < (2,1):
			return vm.FloppyDrive
		else:
			return vm.floppyDrive

	def image_is_accessible(self, image):
		'''Return whether the specified image is accessible.'''
		if self.vbox_ver < (2,1):
			return image.accessible
		else:
			return image.state not in (ifaces.MediaState.Created, \
					ifaces.MediaState.LockedRead)

	def get_image_location(self, image):
		if self.vbox_ver < (2,1):
			return image.filePath
		else:
			return image.location

	def get_image_state(self, image):
		if self.vbox_ver < (2,1):
			if image.accessible:
				return 'accessible'
			else:
				return 'inaccessible'
		else:
			return str(image.state)

def vbox_init():
	global xpcom, ifaces, vbox, compat

	# Locate the VirtualBox program, then use its location to find the
	# path to the Python bindings library
	if 'COMMAND' in dir(vmm):
		program = find_program(vmm.COMMAND)
		if not program:
			raise VmmError(program + ' invalid or not executable')
	else:
		program = find_program('VirtualBox')
		if not program:
			raise VmmError('VirtualBox not found')
	libdir = '/'.join(os.path.normpath(program).split('/')[:-2]) + \
				'/lib/virtualbox'
	if not os.path.isdir(libdir):
		raise VmmError(libdir + ' does not exist')

	# Load the XPCOM bindings
	sys.path.append(libdir)
	__import__('xpcom.vboxxpcom')
	xpcom = __import__('xpcom')
	xpcom.components = __import__('xpcom.components', None, None, 'xpcom')
	ifaces = xpcom.components.interfaces

	# Get a VirtualBox instance and initialize version-compatibility code
	vbox = new_instance(CLASS_VBOX)
	compat = VboxCompat()

def parse_settings_version(ver):
	return tuple(map(int, ver.split('-')[0].split('.')))

def format_version(parts):
	return '.'.join(map(lambda x: str(x), parts))

def new_instance(name):
	return xpcom.components.classes[name].createInstance()

def parcelname():
	return 'openisr-' + vmm.NAME.replace('/', '-')

def handle_signal(sig, frame):
	global signaled
	signaled = True

# Use this from a finally block to ignore exceptions when attempting to close
# a session, so that they do not overwrite any exception that was generated
# in the corresponding try block.
def try_close(sesn):
	try:
		sesn.close()
	except:
		pass

def progress_wait(progress):
	"""Wait for completion on a Progress object, raising an exception if
	the operation fails."""
	progress.waitForCompletion(-1)
	if progress.resultCode:
		raise Exception(progress.errorInfo.text)

def check_runnable():
	"""Determine whether there are any conditions which would prevent us
	from resuming this machine."""

	# Check that we're suspended with the right VMM
	if vmm.SUSPENDED != 'no' and vmm.SUSPENDED != 'virtualbox':
		raise VmmError('Cannot resume: parcel already suspended ' + \
					'with ' + vmm.SUSPENDED)

	# Check against minimum settings version.  If the settings version
	# is newer than what this VirtualBox can understand, we won't even
	# be able to do an openMachine() to check it, so we have to read
	# the XML.
	if os.path.isfile(vm_path):
		want_cfg_ver = parse_settings_version( \
				vbox.settingsFormatVersion)
		mf = MachineFile(vm_path)
		found_cfg_ver = parse_settings_version(mf. \
				descend('VirtualBox').getAttribute('version'))
		mf.close()
		if want_cfg_ver < found_cfg_ver:
			raise VmmError('VirtualBox too old to run this ' \
					'parcel (settings version %s, max %s)' \
					% (format_version(found_cfg_ver), \
					format_version(want_cfg_ver)))

def get_disk_geometry():
	# Always round down
	cyls = min(int(vmm.SECTORS) / (16 * 63), 16383)
	bioscyls = min(int(vmm.SECTORS) / (255 * 63), 1024)
	ddb = dict()
	ddb['ddb.geometry.cylinders'] = cyls
	ddb['ddb.geometry.heads'] = 16
	ddb['ddb.geometry.sectors'] = 63
	ddb['ddb.geometry.biosCylinders'] = bioscyls
	ddb['ddb.geometry.biosHeads'] = 255
	ddb['ddb.geometry.biosSectors'] = 63
	return ddb

def create_disk():
	geom = get_disk_geometry()
	keys = geom.keys()
	keys.sort()
	cid = '%x' % random.randint(0, 0xffffffff)

	f = file(disk_path, 'w')
	f.write('''# Disk DescriptorFile
version=1
CID=%s
parentCID=ffffffff
createType="fullDevice"

RW %s FLAT "%s" 0

ddb.adapterType = "ide"
''' % (cid, vmm.SECTORS, vmm.DISK))
	for k in keys:
		f.write('%s = "%s"\n' % (k, geom[k]))
	f.close()

def create_machine():
	vmname = parcelname()
	vm = compat.create_machine(vmm.CFGDIR, vmname, vmm.UUID)
	vm.memorySize = vmm.MEM
	vm.VRAMSize = 16
	vm.snapshotFolder = '.'
	vm.audioAdapter.enabled = True
	vm.audioAdapter.audioDriver = ifaces.AudioDriverType.Pulse
	try:
		# Not supported with VirtualBox OSE
		vm.USBController.enabled = True
		vm.USBController.enabledEhci = True
	except:
		pass
	net = vm.getNetworkAdapter(0)
	try:
		# Not supported with VirtualBox OSE
		net.adapterType = ifaces.NetworkAdapterType.I82543GC
	except:
		pass
	net.attachToNAT()
	net.enabled = True
	vm.setExtraData('GUI/LastCloseAction', 'save')
	vm.setExtraData('GUI/FirstRun', 'yes')
	vm.saveSettings()
	del vm
	os.rename('%s/%s/%s.xml' % (vmm.CFGDIR, vmname, vmname), vm_path)
	os.rmdir('%s/%s' % (vmm.CFGDIR, vmname))

def fixup_upgrade_settings(mf):
	"""See if this VM has the most recent settings format.  If not, ask
	the user whether to continue.  Return True if upgrade is required.
	This must run during the first pass rather than the second one:
	otherwise, it could leave a UUID conversion half-done if the user
	decides to abort."""

	cfg_ver = mf.descend('VirtualBox').getAttribute('version')
	if cfg_ver == vbox.settingsFormatVersion:
		return False
	print >>sys.stderr, '\nThis parcel is configured for an older', \
				'version of VirtualBox.'
	print >>sys.stderr, 'If you resume the parcel, it will be upgraded', \
				'and will no longer be usable'
	print >>sys.stderr, 'with older versions of VirtualBox.\n'
	cfg_ver = parse_settings_version(vbox.settingsFormatVersion)
	if cfg_ver not in SETTINGS_VERSIONS:
		print >>sys.stderr, 'NOTE: This version of OpenISR does', \
				'not recognize this version of VirtualBox.'
		print >>sys.stderr, 'Resuming this parcel will likely break', \
				'it.  You may continue anyway, but you'
		print >>sys.stderr, 'should be prepared to "isr discard"', \
				'if it fails.\n'
	resp = ''
	while resp != 'y' and resp != 'n':
		sys.stderr.write('Resume parcel? (y/n) ')
		resp = sys.stdin.readline().strip()
	print >>sys.stderr
	if resp != 'y':
		raise VmmError('User declined to upgrade parcel')
	return True

def fixup_uuid_1(mf):
	"""See if this parcel has been cloned.  If so, we need to update all
	unique identifiers associated with the VM.  If necessary, do the
	by-hand fixups and return True.  If this returns True, the Main API
	fixups need to happen later."""

	new_disk_path = disk_path + '.new'
	uuid = '{' + vmm.UUID + '}'

	# We don't want to openMachine() until we know that the UUID is
	# unique on this system.  The VBox API doesn't provide for updating
	# the UUID, so we have to directly update the XML file.  While we're
	# at it, update the VM name as well.
	mach = mf.descend('VirtualBox', 'Machine')
	if mach.getAttribute('uuid') == uuid:
		return False
	mach.setAttribute('name', unicode(parcelname()))
	mach.setAttribute('uuid', unicode(uuid))

	# Update the path to the Nexus virtual disk, and strip UUIDs from
	# the VMDK so that VBox will regenerate them
	ifd = file(disk_path)
	ofd = file(new_disk_path, 'w')
	for line in ifd:
		if line.startswith('RW '):
			parts = line.split(' ')
			parts[3] = '"' + vmm.DISK + '"'
			ofd.write(' '.join(parts))
		elif line.startswith('ddb.uuid'):
			pass
		else:
			ofd.write(line)
	ifd.close()
	ofd.close()
	os.rename(new_disk_path, disk_path)

	return True

def fixup_uuid_2(vm):
	"""Do Main API fixups to change unique identifiers after a parcel
	has been cloned."""

	# Generate new MAC addresses for the VM's Ethernet cards
	for i in range(vbox.systemProperties.networkAdapterCount):
		vm.getNetworkAdapter(i).MACAddress = None

def fixup_invalid_images(mf):
	"""openMachine() will fail if the machine refers to a disk image that
	does not exist.  Manually check and clean the XML to prevent this.
	Return True if we changed something."""

	modified = False
	hw = mf.descend('VirtualBox', 'Machine', 'Hardware')

	types = ('CD', 'DVDDrive', vbox.getDVDImage), \
		('floppy', 'FloppyDrive', vbox.getFloppyImage)
	for name, el, getFunc in types:
		for drive in hw.getElementsByTagName(el):
			img = drive.getElementsByTagName('Image')
			assert len(img) < 2
			if len(img) == 0:
				continue
			uuid = img[0].getAttribute('uuid')
			try:
				getFunc(str(uuid))
			except:
				print >>sys.stderr, 'Unbinding nonexistent', \
							name, 'image', uuid
				drive.removeChild(img[0])
				modified = True
	return modified

def fixup_inaccessible_devices(vm):
	"""Unbind inaccessible devices which will prevent the VM from starting.
	Return True if we have done so."""

	modified = False
	types = ('CD', vm.DVDDrive), ('floppy', compat.get_floppy_drive(vm))
	for name, drive in types:
		if drive.state == ifaces.DriveState.ImageMounted:
			image = drive.getImage()
			if not compat.image_is_accessible(image):
				print >>sys.stderr, 'Unbinding inaccessible', \
					name, 'image', \
					compat.get_image_location(image), \
					'in state:', \
					compat.get_image_state(image)
				drive.unmount()
				modified = True
		elif drive.state == ifaces.DriveState.HostDriveCaptured:
			path = drive.getHostDrive().name
			if not os.access(path, os.R_OK):
				print >>sys.stderr, \
					'Unbinding inaccessible host', name, \
					'drive', path
				drive.unmount()
				modified = True
	return modified

def fixup_disk_size():
	"""Update the virtual disk size in the VMDK file if necessary."""

	new_disk_path = disk_path + '.new'
	geom = get_disk_geometry()

	ifd = file(disk_path)
	out = list()
	for line in ifd:
		key = line.split('=')[0].strip()
		if line.startswith('RW '):
			parts = line.split(' ')
			if int(parts[1]) == int(vmm.SECTORS):
				return False
			parts[1] = vmm.SECTORS
			out.append(' '.join(parts))
		elif geom.has_key(key):
			out.append(key + ' = "' + str(geom[key]) + '"\n')
		else:
			out.append(line)
	ofd = file(new_disk_path, 'w')
	ofd.writelines(out)
	ifd.close()
	ofd.close()
	os.rename(new_disk_path, disk_path)
	return True

def fixup_machine():
	"""Fix the machine configuration prior to running it."""

	# First do the fixups that modify the machine files directly, since
	# otherwise openMachine() may fail.
	mf = MachineFile(vm_path)
	# NOTE: fixup_upgrade_settings() runs during the first pass but
	# commits during the second one!
	did_upgrade = fixup_upgrade_settings(mf)
	did_uuid = fixup_uuid_1(mf)
	did_invalid = fixup_invalid_images(mf)
	fixup_disk_size()
	if did_uuid or did_invalid:
		mf.write()
	mf.close()

	# Now do the fixups that use the Main API.
	vm = vbox.openMachine(vm_path)
	if did_uuid:
		fixup_uuid_2(vm)
	did_inaccessible = fixup_inaccessible_devices(vm)
	if did_uuid or did_inaccessible or did_upgrade:
		vm.saveSettings()

def register_machine():
	disk = compat.register_disk(disk_path)
	vm = vbox.openMachine(vm_path)
	vbox.registerMachine(vm)
	sesn = new_instance(CLASS_SESN)
	vbox.openSession(sesn, vm.id)
	try:
		compat.attach_ide_disk(sesn.machine, disk.id, 0, 0)
		if vmm.FULLSCREEN == 'yes':
			fullscreen = 'on'
		else:
			fullscreen = 'off'
		sesn.machine.setExtraData('GUI/Fullscreen', fullscreen)
		sesn.machine.saveSettings()
		if os.path.isfile(saved_path):
			sesn.console.adoptSavedState(saved_path)
	finally:
		try_close(sesn)

def unregister_state(sesn, do_save):
	have_state = (sesn.machine.state == ifaces.MachineState.Saved)
	if do_save and have_state:
		compat.release_saved_state(sesn, saved_path)
		vmm.SUSPENDED = 'virtualbox'
	else:
		if have_state:
			compat.release_saved_state(sesn)
		vmm.SUSPENDED = 'no'

def unregister_machine(do_save = True):
	try:
		vm = vbox.getMachine(vmm.UUID)
	except:
		pass
	else:
		sesn = new_instance(CLASS_SESN)
		vbox.openSession(sesn, vm.id)
		if sesn.machine.settingsFileVersion != \
					vbox.settingsFormatVersion:
			print >>sys.stderr, 'Warning: Auto-converting VM', \
					'settings file during unregistration'
			sesn.machine.saveSettings()
		try:
			unregister_state(sesn, do_save)
			compat.detach_ide_disk(sesn.machine, 0, 0)
		finally:
			try_close(sesn)
		vbox.unregisterMachine(vm.id)

	compat.unregister_disk(disk_path)

def run_machine():
	global signaled

	sesn = new_instance(CLASS_SESN)
	vmm.SUSPENDED = 'virtualbox'
	start = time.time()
	progress_wait(vbox.openRemoteSession(sesn, vmm.UUID, 'gui', None))
	# It would be better to use IVirtualBoxCallback to wait for a
	# session state change, but it's not clear how to do that from Python.
	# We could loop reading sesn.state, but that deadlocks at session
	# shutdown.  So we loop reading vm.sessionState.  Note that the
	# remote session automatically closes once the direct session closes,
	# so we don't need to do it ourselves.
	vm = vbox.getMachine(vmm.UUID)
	while vm.sessionState != ifaces.SessionState.Closed:
		if signaled:
			signaled = False
			print >>sys.stderr, 'Suspending parcel...',
			try:
				progress_wait(sesn.console.saveState())
			except:
				print >>sys.stderr, 'failed'
			else:
				print >>sys.stderr, 'done'
		time.sleep(0.5)
	if time.time() - start < 20:
		print >>sys.stderr, '''
Your ISR session appears to have been very short, possibly because of a
VirtualBox crash.  If the parcel failed to resume but VirtualBox did not
display an error message, try resuming the parcel again.
'''

def info():
	vmm.VMNAME = 'VirtualBox'
	vbox_init()
	check_runnable()

def run():
	signal.signal(signal.SIGINT, handle_signal)
	vbox_init()
	check_runnable()
	# Make sure there's not a leftover registration from a previous crash
	unregister_machine()
	if not os.path.isfile(disk_path):
		create_disk()
	if not os.path.isfile(vm_path):
		create_machine()
	fixup_machine()
	success = False
	try:
		register_machine()
		run_machine()
		success = True
	finally:
		# Make sure unregister exceptions don't clobber an exception
		# raised in the try block, since the latter is more important
		try:
			unregister_machine()
		except:
			if success:
				raise

def poweroff():
	# Try to unregister the machine if it's still registered.  Fail
	# silently if VirtualBox isn't installed.
	try:
		vbox_init()
	except:
		pass
	else:
		unregister_machine(do_save = False)

	if os.path.isfile(saved_path):
		os.unlink(saved_path)
	if vmm.SUSPENDED == 'virtualbox':
		vmm.SUSPENDED = 'no'

def cleanup():
	# Try to unregister the machine if it's still registered.  Fail
	# silently if VirtualBox isn't installed.
	try:
		vbox_init()
	except:
		pass
	else:
		unregister_machine(do_save = False)

	# Remove logs
	shutil.rmtree(vmm.CFGDIR + '/Logs', True)

vmm.DEBUG = (vmm.VERBOSE == "yes")
vm_path = vmm.CFGDIR + '/virtualbox.xml'
disk_path = vmm.CFGDIR + '/virtualbox.vmdk'
saved_path = vmm.CFGDIR + '/virtualbox.sav'
signaled = False
main()
