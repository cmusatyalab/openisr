#!!!PYTHONPATH!!
#
# virtualbox - OpenISR (R) VMM driver for VirtualBox >= 2.0.0
#
# Copyright (C) 2008-2009 Carnegie Mellon University
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as published
# by the Free Software Foundation.  A copy of the GNU General Public License
# should have been distributed along with this program in the file
# LICENSE.GPL.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

import os
import sys
import signal
import shutil
import time
import random
import xml.dom.minidom
sys.path.insert(1, '!!SHAREDIR!!')
import vmm
from vmm import *

CLASS_VBOX = '@virtualbox.org/VirtualBox;1'
CLASS_SESN = '@virtualbox.org/Session;1'
MIN_VERSION = (2,0,0)
MAX_VERSION = (3,1,99)

class MachineFile:
	def __init__(self, vm_path):
		self.path = vm_path
		self.new_path = vm_path + '.new'
		self.dom = xml.dom.minidom.parse(vm_path)

	def descend(self, *elements):
		tbl = self.dom
		for el in elements:
			tbl = tbl.getElementsByTagName(el)
			assert len(tbl) == 1
			tbl = tbl[0]
		return tbl

	def write(self):
		ofd = file(self.new_path, 'w')
		self.dom.writexml(ofd, encoding = 'UTF-8')
		ofd.close()
		os.rename(self.new_path, self.path)

	def close(self):
		"""Must be called when done with the MachineFile to ensure
		that the data structures are properly cleaned up."""
		self.dom.unlink()
		del self.dom

class VboxCompat:
	def __init__(self):
		parts = map(int, vbox.version.replace('_OSE', '').split('.'))
		if len(parts) != 3:
			raise VmmError("Couldn't parse VirtualBox version: " \
						+ vbox.version)
		self.vbox_ver = tuple(parts)
		if self.vbox_ver < MIN_VERSION:
			raise VmmError("VirtualBox >= %s required (found %s)" \
					% (format_version(MIN_VERSION), \
					vbox.version))

	def version_is_recognized(self):
		return self.vbox_ver <= MAX_VERSION

	def settings_version_is_supported(self, ver):
		if self.vbox_ver < (3,1):
			cur = parse_settings_version( \
						vbox.settingsFormatVersion)
			return cur >= ver
		else:
			# We can't programmatically determine the maximum
			# supported settings version.  We could include a
			# VBox-version => max-settings-version map in this
			# driver, but that would unconditionally prevent us
			# from running on newer versions of VBox and would be
			# error-prone anyway.
			return True

	def settings_version_will_upgrade(self, ver):
		if self.vbox_ver < (3,1):
			cur = parse_settings_version( \
						vbox.settingsFormatVersion)
			return cur != ver
		else:
			# Unregistering the DVD and floppy drives upgrades
			# the settings version to at least 1.9.  For newer
			# settings versions, VBox will upgrade the settings
			# file only if necessary to represent the machine
			# configuration.  We can't predict when this will
			# happen, so return False in this case.
			return ver < (1,9)

	def create_machine(self, vmdir, name, uuid):
		'''Create a machine, configure it to disable VT support, and
		return it.'''
		if self.vbox_ver < (2,1):
			vm = vbox.createMachine(vmdir, name, uuid)
		else:
			vm = vbox.createMachine(name, 'Other', vmdir, uuid)

		if self.vbox_ver < (3,0,2):
			vm.HWVirtExEnabled = ifaces.TSBool.False
		elif self.vbox_ver < (3,1):
			vm.HWVirtExEnabled = False
		else:
			vm.setHWVirtExProperty( \
					ifaces.HWVirtExPropertyType.Enabled,
					False)

		return vm

	def register_disk(self, path):
		'''Register the disk at the specified path and return it.'''
		if self.vbox_ver < (2,1):
			disk = vbox.openHardDisk(path)
			vbox.registerHardDisk(disk)
			return disk
		elif self.vbox_ver < (2,2):
			return vbox.openHardDisk2(path)
		elif self.vbox_ver < (3,0):
			return vbox.openHardDisk(path, \
					ifaces.AccessMode.ReadWrite)
		else:
			return vbox.openHardDisk(path, \
					ifaces.AccessMode.ReadWrite, \
					False, '', False, '')

	def unregister_disk(self, path):
		'''Unregister the disk at the specified path if it exists.'''
		try:
			if self.vbox_ver >= (2,1) and self.vbox_ver < (2,2):
				disk = vbox.findHardDisk2(path)
			else:
				disk = vbox.findHardDisk(path)
		except:
			return
		else:
			if self.vbox_ver < (2,1):
				vbox.unregisterHardDisk(disk.id)
			else:
				disk.close()

	def get_ide_controller(self, sesn_machine):
		if self.vbox_ver < (2,2):
			return ifaces.StorageBus.IDE
		else:
			for ctlr in sesn_machine.getStorageControllers():
				if ctlr.bus == ifaces.StorageBus.IDE:
					return ctlr.name
			# The machine will not have an IDE controller after
			# it is first created, or if the user deletes the
			# controller
			ctlr = sesn_machine.addStorageController( \
						'IDE Controller',
						ifaces.StorageBus.IDE)
			return ctlr.name

	def __get_floppy_controller(self, sesn_machine):
		# Only makes sense on 3.1 and above
		for ctlr in sesn_machine.getStorageControllers():
			if ctlr.bus == ifaces.StorageBus.Floppy:
				return ctlr.name
		# The machine will not have a floppy controller after it is
		# first created, if it has been upgraded from a machine
		# format earlier than 1.9, or if the user deletes the
		# controller
		ctlr = sesn_machine.addStorageController('Floppy Controller',
					ifaces.StorageBus.Floppy)
		return ctlr.name

	def attach_ide_disk(self, sesn_machine, uuid, port, device):
		'''Attach the specified disk to the given machine's IDE
		controller.  The machine handle must be obtained from an open
		session.'''
		ctlr = self.get_ide_controller(sesn_machine)
		if self.vbox_ver >= (2,1) and self.vbox_ver < (2,2):
			sesn_machine.attachHardDisk2(uuid, ctlr, port, device)
		elif self.vbox_ver < (3,1):
			sesn_machine.attachHardDisk(uuid, ctlr, port, device)
		else:
			sesn_machine.attachDevice(ctlr, port, device,
						ifaces.DeviceType.HardDisk,
						uuid)

	def detach_ide_disk(self, sesn_machine, port, device):
		'''Detach the specified disk from the given machine's IDE
		controller, if such an attachment exists.  The machine handle
		must be obtained from an open session.'''
		try:
			ctlr = self.get_ide_controller(sesn_machine)
			if self.vbox_ver >= (2,1) and self.vbox_ver < (2,2):
				sesn_machine.getHardDisk2(ctlr, port, device)
			elif self.vbox_ver < (3,1):
				sesn_machine.getHardDisk(ctlr, port, device)
			else:
				sesn_machine.getMedium(ctlr, port, device)
		except:
			pass
		else:
			if self.vbox_ver >= (2,1) and self.vbox_ver < (2,2):
				sesn_machine.detachHardDisk2(ctlr, port, device)
			elif self.vbox_ver < (3,1):
				sesn_machine.detachHardDisk(ctlr, port, device)
			else:
				sesn_machine.detachDevice(ctlr, port, device)

	def attach_removable_drives(self, sesn_machine):
		'''Attach standard removable drives to the machine.  The
		machine handle must be obtained from an open session.'''
		if self.vbox_ver < (3,1):
			return
		ctlr = self.get_ide_controller(sesn_machine)
		sesn_machine.attachDevice(ctlr, 1, 0, ifaces.DeviceType.DVD,
					'')
		ctlr = self.__get_floppy_controller(sesn_machine)
		sesn_machine.attachDevice(ctlr, 0, 0, ifaces.DeviceType.Floppy,
					'')

	def detach_removable_drives(self, sesn_machine):
		'''Detach standard removable drives from the machine.  The
		machine handle must be obtained from an open session.'''
		if self.vbox_ver < (3,1):
			return
		try:
			ctlr = self.get_ide_controller(sesn_machine)
			sesn_machine.detachDevice(ctlr, 1, 0)
		except:
			pass
		try:
			ctlr = self.__get_floppy_controller(sesn_machine)
			sesn_machine.detachDevice(ctlr, 0, 0)
		except:
			pass

	def fixup_removable_devices(self, mf):
		"""On VirtualBox 3.1 and above, unregistered machines cannot
		have any removable media attached (or, indeed, any removable
		drives) or openMachine() will fail.  On 3.1 and above, strip
		all removable drives from the XML.  On older versions, strip
		all removable media (both images and host drive bindings);
		otherwise, some users would retain mounted media across a
		suspend and others wouldn't.

		VBox >= 3.1 places these devices in a different XML subtree,
		but unregistered 3.1 parcels will never have media attached,
		so we only have to worry about older-format machines."""

		modified = False
		hw = mf.descend('VirtualBox', 'Machine', 'Hardware')

		drives = 'DVDDrive', 'FloppyDrive'
		if self.vbox_ver < (3,1):
			for el in drives:
				for drive in hw.getElementsByTagName(el):
					img = drive.getElementsByTagName( \
								'Image')
					assert len(img) < 2
					if len(img) == 1:
						drive.removeChild(img[0])
						modified = True
					hdrv = drive.getElementsByTagName( \
								'HostDrive')
					assert len(hdrv) < 2
					if len(hdrv) == 1:
						drive.removeChild(hdrv[0])
						modified = True
		else:
			for el in drives:
				for drive in hw.getElementsByTagName(el):
					hw.removeChild(drive)
					modified = True
		return modified

	def release_saved_state(self, sesn, dest_path = None):
		'''Unregister the saved state attached to the given session.
		If dest_path is specified, move the state file to that
		location, otherwise remove it.'''
		if dest_path is not None:
			if self.vbox_ver < (3,0):
				# The stateFilePath may be equal to the
				# dest_path (if the VM was never started
				# successfully), so we rename through a
				# temporary file
				cur_path = dest_path + '.temp'
				os.rename(sesn.machine.stateFilePath, cur_path)
				sesn.console.discardSavedState()
			else:
				cur_path = sesn.machine.stateFilePath
				sesn.console.forgetSavedState(False)
			os.rename(cur_path, dest_path)
		else:
			if self.vbox_ver < (3.0):
				sesn.console.discardSavedState()
			else:
				sesn.console.forgetSavedState(True)

def vbox_init():
	global xpcom, ifaces, vbox, compat

	# Locate the VirtualBox program, then use its location to find the
	# path to the Python bindings library
	if 'COMMAND' in dir(vmm):
		program = find_program(vmm.COMMAND)
		if not program:
			raise VmmError(program + ' invalid or not executable')
	else:
		program = find_program('VirtualBox')
		if not program:
			raise VmmError('VirtualBox not found')
	libdir = '/'.join(os.path.normpath(program).split('/')[:-2]) + \
				'/lib/virtualbox'
	if not os.path.isdir(libdir):
		raise VmmError(libdir + ' does not exist')

	# Load the XPCOM bindings
	sys.path.append(libdir)
	__import__('xpcom.vboxxpcom')
	xpcom = __import__('xpcom')
	xpcom.components = __import__('xpcom.components', None, None, 'xpcom')
	ifaces = xpcom.components.interfaces

	# Get a VirtualBox instance and initialize version-compatibility code
	vbox = new_instance(CLASS_VBOX)
	compat = VboxCompat()

def parse_settings_version(ver):
	return tuple(map(int, ver.split('-')[0].split('.')))

def format_version(parts):
	return '.'.join(map(lambda x: str(x), parts))

def new_instance(name):
	return xpcom.components.classes[name].createInstance()

def parcelname():
	return 'openisr-' + vmm.NAME.replace('/', '-')

def handle_signal(sig, frame):
	global signaled
	signaled = True

# Use this from a finally block to ignore exceptions when attempting to close
# a session, so that they do not overwrite any exception that was generated
# in the corresponding try block.
def try_close(sesn):
	try:
		sesn.close()
	except:
		pass

def progress_wait(progress):
	"""Wait for completion on a Progress object, raising an exception if
	the operation fails."""
	progress.waitForCompletion(-1)
	if progress.resultCode:
		raise Exception(progress.errorInfo.text)

def check_runnable():
	"""Determine whether there are any conditions which would prevent us
	from resuming this machine."""

	# Check that we're suspended with the right VMM
	if vmm.SUSPENDED != 'no' and vmm.SUSPENDED != 'virtualbox':
		raise VmmError('Cannot resume: parcel already suspended ' + \
					'with ' + vmm.SUSPENDED)

	# Check against minimum settings version.  If the settings version
	# is newer than what this VirtualBox can understand, we won't even
	# be able to do an openMachine() to check it, so we have to read
	# the XML.
	if os.path.isfile(vm_path):
		mf = MachineFile(vm_path)
		found_cfg_ver = parse_settings_version(mf. \
				descend('VirtualBox').getAttribute('version'))
		mf.close()
		if not compat.settings_version_is_supported(found_cfg_ver):
			raise VmmError('VirtualBox too old to run this ' \
					'parcel (settings version %s, max %s)' \
					% (format_version(found_cfg_ver), \
					format_version(want_cfg_ver)))

def check_version():
	if compat.version_is_recognized():
		return
	print >>sys.stderr, '\nNOTE: This version of OpenISR does', \
			'not recognize this version of VirtualBox.'
	print >>sys.stderr, 'Resuming this parcel will likely break', \
			'it.  You may continue anyway, but you'
	print >>sys.stderr, 'should be prepared to "isr discard"', \
			'if it fails.\n'

def get_disk_geometry():
	# Always round down
	cyls = min(int(vmm.SECTORS) / (16 * 63), 16383)
	bioscyls = min(int(vmm.SECTORS) / (255 * 63), 1024)
	ddb = dict()
	ddb['ddb.geometry.cylinders'] = cyls
	ddb['ddb.geometry.heads'] = 16
	ddb['ddb.geometry.sectors'] = 63
	ddb['ddb.geometry.biosCylinders'] = bioscyls
	ddb['ddb.geometry.biosHeads'] = 255
	ddb['ddb.geometry.biosSectors'] = 63
	return ddb

def create_disk():
	geom = get_disk_geometry()
	keys = geom.keys()
	keys.sort()
	cid = '%x' % random.randint(0, 0xffffffff)

	f = file(disk_path, 'w')
	f.write('''# Disk DescriptorFile
version=1
CID=%s
parentCID=ffffffff
createType="fullDevice"

RW %s FLAT "%s" 0

ddb.adapterType = "ide"
''' % (cid, vmm.SECTORS, vmm.DISK))
	for k in keys:
		f.write('%s = "%s"\n' % (k, geom[k]))
	f.close()

def create_machine():
	vmname = parcelname()
	vm = compat.create_machine(vmm.CFGDIR, vmname, vmm.UUID)
	vm.memorySize = vmm.MEM
	vm.VRAMSize = 16
	vm.snapshotFolder = '.'
	vm.audioAdapter.enabled = True
	vm.audioAdapter.audioDriver = ifaces.AudioDriverType.Pulse
	try:
		# Not supported with VirtualBox OSE
		vm.USBController.enabled = True
		vm.USBController.enabledEhci = True
	except:
		pass
	net = vm.getNetworkAdapter(0)
	try:
		# Not supported with VirtualBox OSE
		net.adapterType = ifaces.NetworkAdapterType.I82543GC
	except:
		pass
	net.attachToNAT()
	net.enabled = True
	vm.setExtraData('GUI/LastCloseAction', 'save')
	vm.setExtraData('GUI/FirstRun', 'yes')
	vm.saveSettings()
	del vm
	os.rename('%s/%s/%s.xml' % (vmm.CFGDIR, vmname, vmname), vm_path)
	os.rmdir('%s/%s' % (vmm.CFGDIR, vmname))

def fixup_upgrade_settings(mf):
	"""See if this VM has the most recent settings format.  If not, ask
	the user whether to continue.  Return True if upgrade is required.
	This must run during the first pass rather than the second one:
	otherwise, it could leave a UUID conversion half-done if the user
	decides to abort."""

	cfg_ver = mf.descend('VirtualBox').getAttribute('version')
	cfg_ver = parse_settings_version(cfg_ver)
	if not compat.settings_version_will_upgrade(cfg_ver):
		return False
	print >>sys.stderr, '\nThis parcel is configured for an older', \
				'version of VirtualBox.'
	print >>sys.stderr, 'If you resume the parcel, it will be upgraded', \
				'and will no longer be usable'
	print >>sys.stderr, 'with older versions of VirtualBox.\n'
	resp = ''
	while resp != 'y' and resp != 'n':
		sys.stderr.write('Resume parcel? (y/n) ')
		resp = sys.stdin.readline().strip()
	print >>sys.stderr
	if resp != 'y':
		raise VmmError('User declined to upgrade parcel')
	return True

def fixup_uuid_1(mf):
	"""See if this parcel has been cloned.  If so, we need to update all
	unique identifiers associated with the VM.  If necessary, do the
	by-hand fixups and return True.  If this returns True, the Main API
	fixups need to happen later."""

	new_disk_path = disk_path + '.new'
	uuid = '{' + vmm.UUID + '}'

	# We don't want to openMachine() until we know that the UUID is
	# unique on this system.  The VBox API doesn't provide for updating
	# the UUID, so we have to directly update the XML file.  While we're
	# at it, update the VM name as well.
	mach = mf.descend('VirtualBox', 'Machine')
	if mach.getAttribute('uuid') == uuid:
		return False
	mach.setAttribute('name', unicode(parcelname()))
	mach.setAttribute('uuid', unicode(uuid))

	# Update the path to the Nexus virtual disk, and strip UUIDs from
	# the VMDK so that VBox will regenerate them
	ifd = file(disk_path)
	ofd = file(new_disk_path, 'w')
	for line in ifd:
		if line.startswith('RW '):
			parts = line.split(' ')
			parts[3] = '"' + vmm.DISK + '"'
			ofd.write(' '.join(parts))
		elif line.startswith('ddb.uuid'):
			pass
		else:
			ofd.write(line)
	ifd.close()
	ofd.close()
	os.rename(new_disk_path, disk_path)

	return True

def fixup_uuid_2(vm):
	"""Do Main API fixups to change unique identifiers after a parcel
	has been cloned."""

	# Generate new MAC addresses for the VM's Ethernet cards
	for i in range(vbox.systemProperties.networkAdapterCount):
		vm.getNetworkAdapter(i).MACAddress = None

def fixup_disk_size():
	"""Update the virtual disk size in the VMDK file if necessary."""

	new_disk_path = disk_path + '.new'
	geom = get_disk_geometry()

	ifd = file(disk_path)
	out = list()
	for line in ifd:
		key = line.split('=')[0].strip()
		if line.startswith('RW '):
			parts = line.split(' ')
			if int(parts[1]) == int(vmm.SECTORS):
				return False
			parts[1] = vmm.SECTORS
			out.append(' '.join(parts))
		elif geom.has_key(key):
			out.append(key + ' = "' + str(geom[key]) + '"\n')
		else:
			out.append(line)
	ofd = file(new_disk_path, 'w')
	ofd.writelines(out)
	ifd.close()
	ofd.close()
	os.rename(new_disk_path, disk_path)
	return True

def fixup_machine():
	"""Fix the machine configuration prior to running it."""

	# First do the fixups that modify the machine files directly, since
	# otherwise openMachine() may fail.
	mf = MachineFile(vm_path)
	# NOTE: fixup_upgrade_settings() runs during the first pass but
	# commits during the second one!
	did_upgrade = fixup_upgrade_settings(mf)
	did_uuid = fixup_uuid_1(mf)
	did_removable = compat.fixup_removable_devices(mf)
	fixup_disk_size()
	if did_uuid or did_removable:
		mf.write()
	mf.close()

	# Now do the fixups that use the Main API.
	vm = vbox.openMachine(vm_path)
	if did_uuid:
		fixup_uuid_2(vm)
	if did_uuid or did_upgrade:
		vm.saveSettings()

def register_machine():
	disk = compat.register_disk(disk_path)
	vm = vbox.openMachine(vm_path)
	vbox.registerMachine(vm)
	sesn = new_instance(CLASS_SESN)
	vbox.openSession(sesn, vm.id)
	try:
		compat.attach_ide_disk(sesn.machine, disk.id, 0, 0)
		compat.attach_removable_drives(sesn.machine)
		if vmm.FULLSCREEN == 'yes':
			fullscreen = 'on'
		else:
			fullscreen = 'off'
		sesn.machine.setExtraData('GUI/Fullscreen', fullscreen)
		sesn.machine.saveSettings()
		if os.path.isfile(saved_path):
			sesn.console.adoptSavedState(saved_path)
	finally:
		try_close(sesn)

def unregister_state(sesn, do_save):
	have_state = (sesn.machine.state == ifaces.MachineState.Saved)
	if do_save and have_state:
		compat.release_saved_state(sesn, saved_path)
		vmm.SUSPENDED = 'virtualbox'
	else:
		if have_state:
			compat.release_saved_state(sesn)
		vmm.SUSPENDED = 'no'

def unregister_machine(do_save = True):
	try:
		vm = vbox.getMachine(vmm.UUID)
	except:
		pass
	else:
		sesn = new_instance(CLASS_SESN)
		vbox.openSession(sesn, vm.id)
		try:
			unregister_state(sesn, do_save)
			compat.detach_removable_drives(sesn.machine)
			compat.detach_ide_disk(sesn.machine, 0, 0)
		finally:
			sesn.machine.saveSettings()
			try_close(sesn)
		vbox.unregisterMachine(vm.id)

	compat.unregister_disk(disk_path)

def run_machine():
	global signaled

	sesn = new_instance(CLASS_SESN)
	vmm.SUSPENDED = 'virtualbox'
	start = time.time()
	progress_wait(vbox.openRemoteSession(sesn, vmm.UUID, 'gui', None))
	# It would be better to use IVirtualBoxCallback to wait for a
	# session state change, but it's not clear how to do that from Python.
	# We could loop reading sesn.state, but that deadlocks at session
	# shutdown.  So we loop reading vm.sessionState.  Note that the
	# remote session automatically closes once the direct session closes,
	# so we don't need to do it ourselves.
	vm = vbox.getMachine(vmm.UUID)
	while vm.sessionState != ifaces.SessionState.Closed:
		if signaled:
			signaled = False
			print >>sys.stderr, 'Suspending parcel...',
			try:
				progress_wait(sesn.console.saveState())
			except:
				print >>sys.stderr, 'failed'
			else:
				print >>sys.stderr, 'done'
		time.sleep(0.5)
	if time.time() - start < 20:
		print >>sys.stderr, '''
Your ISR session appears to have been very short, possibly because of a
VirtualBox crash.  If the parcel failed to resume but VirtualBox did not
display an error message, try resuming the parcel again.
'''

def info():
	vmm.VMNAME = 'VirtualBox'
	vbox_init()
	check_runnable()

def run():
	signal.signal(signal.SIGINT, handle_signal)
	vbox_init()
	check_runnable()
	check_version()
	# Make sure there's not a leftover registration from a previous crash
	unregister_machine()
	if not os.path.isfile(disk_path):
		create_disk()
	if not os.path.isfile(vm_path):
		create_machine()
	fixup_machine()
	success = False
	try:
		register_machine()
		run_machine()
		success = True
	finally:
		# Make sure unregister exceptions don't clobber an exception
		# raised in the try block, since the latter is more important
		try:
			unregister_machine()
		except:
			if success:
				raise

def poweroff():
	# Try to unregister the machine if it's still registered.  Fail
	# silently if VirtualBox isn't installed.
	try:
		vbox_init()
	except:
		pass
	else:
		unregister_machine(do_save = False)

	if os.path.isfile(saved_path):
		os.unlink(saved_path)
	if vmm.SUSPENDED == 'virtualbox':
		vmm.SUSPENDED = 'no'

def cleanup():
	# Try to unregister the machine if it's still registered.  Fail
	# silently if VirtualBox isn't installed.
	try:
		vbox_init()
	except:
		pass
	else:
		unregister_machine(do_save = False)

	# Remove logs
	shutil.rmtree(vmm.CFGDIR + '/Logs', True)

vmm.DEBUG = (vmm.VERBOSE == "yes")
vm_path = vmm.CFGDIR + '/virtualbox.xml'
disk_path = vmm.CFGDIR + '/virtualbox.vmdk'
saved_path = vmm.CFGDIR + '/virtualbox.sav'
signaled = False
main()
