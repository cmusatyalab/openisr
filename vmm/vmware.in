#!!!PERLPATH!!
#
# vmware - OpenISR (R) VMM driver for VMware Workstation and VMware Player
#
# Copyright (C) 2008-2009 Carnegie Mellon University
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as published
# by the Free Software Foundation.  A copy of the GNU General Public License
# should have been distributed along with this program in the file
# LICENSE.GPL.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

BEGIN {
	do "!!SHAREDIR!!/vmm.pm";
	die "Couldn't load vmm.pm: $!\n"
		if $!;
	die "Couldn't parse vmm.pm: $@\n"
		if $@;
	import vmm;
}

use Cwd qw/abs_path/;
use strict;
use warnings;

my $program;

# Return key and value, or undef on parse error.
sub split_record {
	my $line = shift;

	$line =~ /^([^=\s]+)\s*=\s*([^\n]+)\n$/
		or return undef;
	return ($1, $2);
}

sub find_vmx {
	my $vmx;
	my $dent;

	# New canonical location
	return "vmware.vmx"
		if -f "$CFGDIR/vmware.vmx";

	# Search the cfg directory for legacy VMXes
	opendir DIR, $CFGDIR
		or fail "Couldn't read cfg directory";
	while ($dent = readdir(DIR)) {
		next if $dent !~ /\.vmx$/;
		fail "Too many VMX files in $CFGDIR"
			if defined $vmx;
		$vmx = $dent;
	}
	closedir DIR;
	return $vmx;
}

sub check_runnable {
	fail "Cannot resume: parcel already suspended with $SUSPENDED"
		if $SUSPENDED ne "no" and $SUSPENDED ne "vmware";
	if (defined $COMMAND) {
		fail "$COMMAND invalid or not executable"
			unless defined ($program = find_program $COMMAND);
	} else {
		foreach my $prog ('vmplayer', 'vmware') {
			last if defined ($program = find_program $prog);
		}
		fail "VMware not found"
			unless defined $program;
	}
	# Make sure we can locate a specific VMX file to run
	find_vmx;
}

sub info {
	$VMNAME = "VMware";
	check_runnable;
}

sub new_vmdata {
	my $cid = sprintf("%x", int(rand(0xffffffff)));
	# Always round down
	my $cyls = int($SECTORS / (16 * 63));
	my $bioscyls = int($SECTORS / (255 * 63));
	$cyls = 16383 if $cyls > 16383;
	$bioscyls = 1024 if $bioscyls > 1024;

	open(VMDK, ">", "$CFGDIR/vmware.vmdk")
		or fail "Unable to write to $CFGDIR/vmware.vmdk";
	print VMDK <<EOF;
version=1
CID=$cid
parentCID=ffffffff
createType="fullDevice"

RW $SECTORS FLAT "/dev/hdk" 0

ddb.virtualHWVersion = "6"
ddb.geometry.cylinders = "$cyls"
ddb.geometry.heads = "16"
ddb.geometry.sectors = "63"
ddb.geometry.biosCylinders = "$bioscyls"
ddb.geometry.biosHeads = "255"
ddb.geometry.biosSectors = "63"
ddb.adapterType = "ide"
EOF
	close(VMDK);

	open(VMX, ">", "$CFGDIR/vmware.vmx")
		or fail "Unable to write to $CFGDIR/vmware.vmx";
	print VMX <<EOF;
config.version = "7"
virtualHW.version = "6"
displayName = "$NAME"
guestOS = "other26xlinux"
memsize = "$MEM"
ide0:0.present = "TRUE"
ide0:0.fileName = "vmware.vmdk"
ide0:0.deviceType = "rawDisk"
ide0:1.present = "TRUE"
ide0:1.deviceType = "cdrom-raw"
ide0:1.autodetect = "TRUE"
floppy0.present = "FALSE"
Ethernet0.present = "TRUE"
Ethernet0.connectionType = "nat"
sound.present = "TRUE"
sound.autodetect = "TRUE"
usb.present = "TRUE"
ehci.present = "TRUE"
tools.remindInstall = "TRUE"
undopoint.disableSnapshots = "TRUE"
uuid.action = "keep"
nvram = "vmware.nvram"
EOF
	close(VMX);
}

sub try_rename {
	my $from = shift;
	my $to = shift;

	fail "$to already exists; will not overwrite"
		if -e "$CFGDIR/$to";
	rename("$CFGDIR/$from", "$CFGDIR/$to")
		or fail "Couldn't rename $CFGDIR/$from";
}

sub new_filenames {
	my $vmx = shift;

	my $vmdk;
	my $vmxf;
	my $nvram;
	my $base;
	my $ext;
	my $line;
	my $key;
	my $value;
	my @files;
	my $file;

	open(OLD, "<", "$CFGDIR/$vmx")
		or fail "Couldn't read $vmx";
	open(NEW, ">", "$CFGDIR/vmware.vmx")
		or fail "Couldn't write new vmware.vmx";
	while ($line = <OLD>) {
		($key, $value) = split_record($line);
		unless (defined $key) {
			print NEW $line;
			next;
		}
		$value =~ s/"//g;
		if ($key =~ /fileName$/ and $value =~ /.vmdk$/) {
			fail "Parcel associated with more than one VMDK; "
						. "bailing out"
				if defined $vmdk;
			$vmdk = $value;
			print NEW "$key = \"vmware.vmdk\"\n";
		} elsif ($key eq "extendedConfigFile") {
			$vmxf = $value;
			print NEW "extendedConfigFile = \"vmware.vmxf\"\n";
		} elsif ($key eq "checkpoint.vmState") {
			# This key does not appear to be respected by
			# current VMware, and misleadingly gives a filename
			# for the VMSS file.  Drop the line.
		} elsif ($key eq "nvram") {
			$nvram = $value;
			print NEW "nvram = \"vmware.nvram\"\n";
		} else {
			print NEW $line;
		}
	}
	unless (defined $nvram) {
		$nvram = "nvram";
		print NEW "nvram = \"vmware.nvram\"\n";
	}
	close(OLD);
	close(NEW);
	unlink "$CFGDIR/$vmx"
		or fail "Couldn't unlink $vmx";

	try_rename $vmdk, "vmware.vmdk"
		if $vmdk ne "vmware.vmdk";

	try_rename $nvram, "vmware.nvram"
		if $nvram ne "vmware.nvram" and -e "$CFGDIR/$nvram";

	if (defined $vmxf and $vmxf ne "vmware.vmxf") {
		fail "vmware.vmxf already exists; will not overwrite"
			if -e "$CFGDIR/vmware.vmxf";
		open(OLD, "<", "$CFGDIR/$vmxf")
			or fail "Couldn't read $vmxf";
		open(NEW, ">", "$CFGDIR/vmware.vmxf")
			or fail "Couldn't write new vmware.vmxf";
		while ($line = <OLD>) {
			$line =~ s/$vmx/vmware.vmx/g
				if $line =~ /vmxPathName/;
			print NEW $line;
		}
		close OLD;
		close NEW;
		unlink "$CFGDIR/$vmxf"
			or fail "Couldn't unlink $vmxf";
	}

	($base = $vmx) =~ s/\.vmx$//;
	opendir DIR, $CFGDIR
		or fail "Couldn't read cfg directory";
	@files = grep /^$base\./, readdir(DIR);
	closedir DIR;
	foreach $file (@files) {
		($ext = $file) =~ s/^$base\.//;
		# If the file is of a type which requires it to be explicitly
		# listed in the VMX file, then we don't want to rename it
		# here: we've already found the canonical copy and renamed it,
		# so despite its basename the file we've found here is not
		# really associated with the VM.
		next if $ext =~ /^vmdk|vmxf|nvram$/;
		try_rename "$base.$ext", "vmware.$ext";
	}
}

sub new_uuid {
	my $vmx = "$CFGDIR/vmware.vmx";
	my $vmdk;
	my $line;
	my $key;
	my $value;

	open(OLD, "<", $vmx)
		or fail "Couldn't read $vmx";
	open(NEW, ">", "$vmx.new")
		or fail "Couldn't write $vmx.new";
	while ($line = <OLD>) {
		($key, $value) = split_record($line);
		unless (defined $key) {
			print NEW $line;
			next;
		}
		next if $key =~ /ethernet[0-9]+\.addressType/;
		next if $key =~ /ethernet[0-9]+\.generatedAddress/;
		next if $key =~ /uuid\.(location|bios)/;
		if ($key =~ /fileName$/ and $value =~ /.vmdk"$/) {
			fail "Parcel associated with more than one VMDK; "
						. "bailing out"
				if defined $vmdk;
			$vmdk = $value;
			$vmdk =~ s/"//g;
			$vmdk = "$CFGDIR/$vmdk";
		}
		if ($key eq "displayName") {
			print NEW "displayName = \"$NAME\"\n";
		} else {
			print NEW $line;
		}
	}
	close(OLD);
	close(NEW);
	rename("$vmx.new", $vmx)
		or fail "Couldn't update $vmx";

	open(OLD, "<", $vmdk)
		or fail "Couldn't read $vmdk";
	open(NEW, ">", "$vmdk.new")
		or fail "Couldn't write $vmdk.new";
	while ($line = <OLD>) {
		($key, $value) = split_record($line);
		unless (defined $key) {
			print NEW $line;
			next;
		}
		next if $key =~ /ddb\.uuid/;
		print NEW $line;
	}
	close(OLD);
	close(NEW);
	rename("$vmdk.new", $vmdk)
		or fail "Couldn't update $vmdk";
}

sub update_cfg {
	my $need_refresh = 0;
	my $refreshed = 0;
	my $old_id;
	my $uufile = "$CFGDIR/vmware.uuid";
	my $vmx;

	$vmx = find_vmx;
	new_filenames $vmx
		if defined $vmx and $vmx ne "vmware.vmx";
	if (!defined $vmx) {
		# This parcel has no VMX file.  Create a VMX and VMDK.
		new_vmdata;
		$refreshed = 1;
	} elsif (-e $uufile) {
		# This parcel has a UUID file.  Make sure it matches the
		# current parcel's UUID.  If not, the parcel has been cloned,
		# and we need to clean out unique identifiers in the VMX
		# and VMDK.
		open(UUFILE, $uufile)
			or fail "Couldn't read $uufile";
		$old_id = <UUFILE>;
		chomp $old_id;
		close UUFILE;
		$need_refresh = 1
			if $old_id ne $UUID;
	} else {
		# This parcel has no UUID file, which means it has only been
		# used with older versions of OpenISR.  Update the VMware
		# unique identifiers just to be safe.  (This used to be done
		# in isr_admin copyparcel, but newer versions don't do this,
		# and the parcel may have been cloned by newer versions.
		# Also, older versions of isr_admin didn't do this either, so
		# old parcels may have non-unique identifiers that we need
		# to correct.)
		$need_refresh = 1;
	}

	if ($need_refresh) {
		new_uuid;
		$refreshed = 1;
	}
	if ($refreshed) {
		open(UUFILE, ">", $uufile)
			or fail "Couldn't write $uufile";
		print UUFILE "$UUID\n";
		close UUFILE;
	}
}

# When we run VMware, our immediate child is not the binary itself, but a
# shell script which runs the binary and which ignores SIGINT.  To ask VMware
# to exit, we need to send SIGINT to the child *of the shell script*.
my $signaled = 0;
sub kill_vmware {
	my $pid = shift;

	my $child_bin;
	my $shell_path;
	my $cur;
	my $ppid;

	return if $signaled;
	$signaled = 1;
	print STDERR "Suspending parcel...\n";
	# Get the binary being run by our child, and compare it to /bin/sh.
	# /bin/sh may be a symlink, so we need to canonicalize it.
	$child_bin = readlink "/proc/$pid/exe"
		or return;
	$shell_path = abs_path "/bin/sh";
	if ($child_bin ne $shell_path) {
		# Our child is not a shell, so just signal it directly.
		kill 'INT', $pid;
		return;
	}
	# Send SIGINT to all children of $pid.
	opendir(PROC, "/proc")
		or return;
	foreach $cur (readdir PROC) {
		next if $cur !~ /^[0-9]+$/;
		open(STAT, "/proc/$cur/stat")
			or next;
		$ppid = (split ' ', <STAT>)[3];
		close STAT;
		kill 'INT', $cur
			if $ppid == $pid;
	}
	closedir PROC;
}

sub run {
	my $ret;
	my $opts;

	$opts = ($FULLSCREEN eq "yes" ? "-X" : "");
	check_runnable;
	update_cfg;
	{
		local $ENV{'LD_PRELOAD'} = "libvdisk.so.0";
		local $ENV{'VDISK_DEVICE'} = $DISK;
		$ret = run_program("$program $opts $CFGDIR/vmware.vmx",
					\&kill_vmware, ($VERBOSE ne "yes"));
	}
	fail "Couldn't run $program"
		if $ret == -1;

	$SUSPENDED = "vmware";
	opendir DIR, $CFGDIR
		or fail "Couldn't read cfg directory";
	if (grep(/\.vmem$/, readdir(DIR))) {
		$SUSPENDED = "vmware";
	} else {
		$SUSPENDED = "no";
	}
	closedir DIR;
	fail "$program returned $ret"
		if $ret;
}

sub cleanup {
	opendir(CDIR, $CFGDIR)
		or fail "Can't read directory $CFGDIR";
	foreach my $file (grep(/^(vmware(-core\.gz|.*\.log))|core$/,
				readdir(CDIR))) {
		unlink "$CFGDIR/$file"
			or fail "Couldn't remove $CFGDIR/$file";
	}
	closedir(CDIR);
}

main;
