#!/usr/bin/perl

####################################################################
# isr_setup - builds an ISR client, name server, or content server
#
# $Id: isr_setup,v 1.37 2005/07/13 17:05:14 mtoups Exp $
####################################################################

#
#                  Internet Suspend/Resume (Release 1.1)
#           A system for capture and transport of PC state
#
#              Copyright (c) 2002-2004, Intel Corporation
#            Copyright (c) 2004, Carnegie Mellon University
#                         All Rights Reserved
#
# This software is distributed under the terms of the Eclipse Public
# License, Version 1.0 which can be found in the file named LICENSE.
# ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES
# RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT
#

#
# Standard prologue
#
use strict;
use Getopt::Std;
use File::Basename;
use Term::ANSIColor qw(:constants);
use Sys::Hostname;

$| = 1; # Autoflush output on every print statement

#
# Configuration variables
#

# URL for the content on the update server
my $UPDATEURL = "http://isr.cmu.edu/software";

# Options to use with curl (useful for setting up a proxy connection)
# For proxy connection: $CURLOPTS = "-x proxy.foo.com:8000";
my $CURLOPTS = "";

# VMWARE RPM
my $VMWARERPM = "VMware-workstation-4.5.2-8848.i386.rpm";

# Default user name
my $DEFAULTUSER = "isruser";

# ISR bin directory
my $ISRCLIENTBINDIR = "/usr/local/isr/bin";
my $ISRSERVERBINDIR = "/usr/local/isr/bin";

# Where the ISR man page should go
my $ISRMANDIR = "/usr/share/man/man1";

# Temporary directory basename
my $TEMPDIRBASE = "/tmp/isr_setup";

#
# Extract the command and define local variables
#
if (@ARGV == 0) {
    usage("Missing command.");
}
if (@ARGV > 1 and $ARGV[0] ne "user" or @ARGV > 2) {
    usage("Too many commands.");
}

my $isruser = $DEFAULTUSER;
my $command = $ARGV[0];

if ($command eq "user") {
    if (@ARGV != 2 ) {
	usage("Must specify <username>.");
    }
    $isruser = $ARGV[1];
}

if ($command eq "help") {
    usage();
}

if ($command ne "client" and 
    $command ne "srv" and 
    $command ne "nsrv" and 
    $command ne "clean" and 
    $command ne "update" and 
    $command ne "user") {
    usage ("Not a valid command.");
}

my $hostid = int(rand(1<<30));
my $running_version = `uname -r`; chomp($running_version);
my $target;


#
# Create a temporary working directory and make that the current
# directory for this process. 
#
my $tempdir = "$TEMPDIRBASE.$$";
system("rm -rf $TEMPDIRBASE.* > /dev/null 2>&1"); 
system("mkdir $tempdir") == 0
    or errexit("Unable to create temp directory: $tempdir");
chdir($tempdir)
    or errexit("Unable to change cwd: $tempdir");

#
# Confirm that user is root
#
if ($> != 0 and $command ne "update") {
    errexit("This script must be run as root.");
}

#
# Special case: command is "clean"
#
if ($command eq "clean") {

    if(-e "/home/isruser") {
	print BLUE, "Destroying generic user account [isruser]...\n", RESET;
	system("userdel -r isruser");
	system("groupdel isrgroup"); 
	system("sleep 1");
    }

    if (-e "$ISRCLIENTBINDIR") {
	print BLUE, "Deleting [$ISRCLIENTBINDIR]...\n", RESET;
	system("rm -rf /usr/local/isr");
	system("sleep 1");
    }

    if (-e "/usr/bin/vmware-config.pl") {
	print BLUE, "Uninstalling [VMwareWorkstation]...\n", RESET;
	system("rpm -e VMwareWorkstation");
	system("sleep 1");
    }

    if (-e "/lib/modules/$running_version/misc/fauxide.o") {
	print BLUE, "Uninstalling [fauxide.o]...\n", RESET;
	system("rmmod fauxide");
	system("rm -f /lib/modules/$running_version/misc/fauxide.o");
    }

    system("chown root:disk /dev/hdk*");
    system("rm -rf /etc/init.d/vulpes_stop /etc/rc6.d/K09vulpes");

    print RED, "Warning: There may still be traces of ISR in:\n", RESET;
    print RED, " /etc/modules.conf\n", RESET;
    print GREEN, "Success: Clean completed.\n\n", RESET;
    exit 0;
}

#
# Special case: command is "user" 
#
if ($command eq "user") {
    system("/usr/sbin/useradd -n -g isrgroup -d /home/$isruser/ $isruser");
    system("echo 'changeme' | passwd --stdin $isruser");
    system("mkdir /home/$isruser/.isr");
    exit 0;
}

#
# Create isrgroup
#
if (! -e "/home/isruser") {
    print BLUE, "Creating group [isrgroup]...\n", RESET;
    system("groupadd isrgroup");
}

#
# Create isruser account
#
if (! -e "/home/isruser") {
    print BLUE, "Creating generic user account [isruser] with password [changeme]...\n", RESET;
    system("/usr/sbin/useradd -n -g isrgroup -d /home/isruser/ isruser");
    system("echo 'changeme' | passwd --stdin isruser >> /dev/null");
}

#
# Create local cache directory for isruser
#
if ($command eq "client" or $command eq "nsrv") {
    if (! -e "/home/isruser/.isr") {
	print BLUE, "Creating local isr cache directory [/home/isruser/.isr]...\n", RESET;
	system("mkdir /home/isruser/.isr");
    }
}

#
# Create the ISRCLIENTBIN directory
#
if (! -e "$ISRCLIENTBINDIR") {
    print BLUE, "Creating directory [$ISRCLIENTBINDIR]...\n" , RESET;
    system("mkdir --parents $ISRCLIENTBINDIR") == 0
	or errexit("Cannot create [$ISRCLIENTBINDIR/]");
}

#
# Populate the ISRCLIENTBIN directory
#
my @targetlist = ();
print BLUE, "Updating [$ISRCLIENTBINDIR]...\n", RESET;
if ($command eq "client" or $command eq "update") {

    # The update command should not modify the Isruser.pm file
    if ($command eq "client") {
	@targetlist = ("isr", "isr.1", "Isr.pm", "Isruser.pm", "isr_gui", "HTTPSSH.pm", "CODA.pm", "LICENSE", "README", "VERSION", "vulpes", "vulpes_stop");
    }
    elsif ($command eq "update") {
	@targetlist = ("isr", "isr.1", "Isr.pm", "isr_gui", "HTTPSSH.pm", "CODA.pm", "LICENSE", "README", "VERSION", "vulpes", "vulpes_stop");
    }

    # Download the files and move them to the bin directory
    foreach $target (@targetlist) {
	print "   Downloading $target...\n", RESET;
	system("curl $CURLOPTS -s -G -O $UPDATEURL/client/$target") == 0
	    or system_errexit("Unable to download file $target to $tempdir.");
	system("cp $target $ISRCLIENTBINDIR/$target") == 0
	    or system_errexit("Cannot copy $target to $ISRCLIENTBINDIR");
    }

    if ($command eq "client") {
	system("echo $hostid > $ISRCLIENTBINDIR/.hostid");
    }

    # If running as root, install vulpes_stop and the man page.
    if ($> == 0) {
	if ($command ne "update") { # update won't mess with this for now
	    system("mv $ISRCLIENTBINDIR/vulpes_stop /etc/init.d/vulpes_stop") == 0
		or errexit("Cannot move vulpes_stop to /etc/init.d/");
	    system("rm -f /etc/rc6.d/K09vulpes") == 0
		or errexit("Unable to delete symbolic link: /etc/rc6.d/K09vulpes");
	    system("ln -s /etc/init.d/vulpes_stop /etc/rc6.d/K09vulpes") == 0
		or errexit("Cannot create symbolic link: /etc/rc6.d/K09vulpes");
	}
	system("mv $ISRCLIENTBINDIR/isr.1 $ISRMANDIR/isr.1") == 0
	    or errexit("Cannot move man page isr.1 to $ISRMANDIR");
    }
    else {
	print BLUE, "Note: to update the ISR man page, login as root and run \n\"cp $ISRCLIENTBINDIR/isr.1 $ISRMANDIR\"\n", RESET;
    }
}

elsif ($command eq "nsrv") {
    foreach $target ("isr_nsrv_getconfig.pl", "isr_nsrv_listparcels.pl", "Server.pm", "LICENSE") {
	print RED, "   $target\n", RESET;
	system("curl $CURLOPTS -s -G -O $UPDATEURL/srv/$target") == 0
	    or errexit("Cannot download sources, verify your internet connection.");
	system("mv $target $ISRSERVERBINDIR/$target") == 0
	    or errexit("Cannot move $target to $ISRSERVERBINDIR");
    }
}

elsif ($command eq "srv") {
    foreach $target ("isr_srv_checkparcel.pl", "isr_srv_commit.pl", "isr_srv_ls.pl", "isr_srv_lock.pl", 
		     "isr_srv_rollback.pl", "isr_srv_resetcache.pl", "Server.pm", "README", "LICENSE") {
	print RED, "   $target\n", RESET;
	system("curl $CURLOPTS -s -G -O $UPDATEURL/srv/$target") == 0
	    or errexit("Cannot download sources, verify your internet connection.");
	
	system("mv $target $ISRSERVERBINDIR/$target") == 0
	    or errexit("Cannot move $target to $ISRSERVERBINDIR");
    }
}

#
# Update Curl
#
if ($command eq "client") {
    print BLUE, "Downloading [Curl]...\n", RESET;
    system("curl $CURLOPTS -s -G -O $UPDATEURL/client/curl.tgz") == 0
	or errexit("Cannot download Curl, check your internet connection.");
    print BLUE, "Unpacking [Curl]...\n", RESET;
    system("tar xzf curl.tgz");
    print BLUE, "Installing [Curl] (this may take a minute)...\n", RESET;
    system("cd curl-7.12.1; ./configure --prefix=/usr --exec-prefix=/usr >> /dev/null; make >> /dev/null; make install >> /dev/null; cd ..; rm -rf curl-7.12.1; rm -rf curl.tgz");
}

#
# Install VMWare
#
if ($command eq "client") {
    if (! -e "/usr/bin/vmware-config.pl") {
	print BLUE, "Downloading [VMwareWorkstation]...\n", RESET;
	print RED, "   $VMWARERPM\n", RESET;
	system("curl $CURLOPTS -s -G -O $UPDATEURL/client/$VMWARERPM") == 0
	    or errexit("Cannot download VMwareWorkstation, check your internet connection.");
	print BLUE, "Installing [VMwareWorkstation]...\n", RESET;
	system("rpm -Uhv $VMWARERPM");
	print BLUE, "Configuring [VMwareWorkstation]...\n", RESET;
	system("vmware-config.pl");
    }
    system("rm -rf $VMWARERPM");
}

#
# Setup /dev/hdk
#
if ($command eq "client") {
    print BLUE, "Setting up [/dev/hdk] (virtual hard drive device)...\n", RESET;
    my $i = 0;

    # if an old backup directory exists, move it to .old
    system("mv -f /dev/hdk-pre-isr-install /dev/hdk-pre-isr-install.old");

    system("mkdir /dev/hdk-pre-isr-install") == 0
        or errexit("Could not create /dev/hdk-pre-isr-install");

    # if a .old backup directory exists, move it to the new directory
    system("mv -f /dev/hdk-pre-isr-install.old /dev/hdk-pre-isr-install");

    system("mv /dev/hdk /dev/hdk-pre-isr-install/");
    system("mknod /dev/hdk b 242 0") == 0
        or errexit("Could not create /dev/hdk");
    for ($i=1; $i<16; $i++) {
        system("mv /dev/hdk$i /dev/hdk-pre-isr-install/");
        system("mknod /dev/hdk$i b 242 $i") == 0
    	or errexit("Could not create /dev/hdk");
    }
}

#
# Install fauxide module for clients
#
if ($command eq "client") {

    print BLUE, "Updating fauxide kernel module and installing vulpes...\n", RESET;
    print RED, "   fauxide.tgz\n", RESET;
    system("curl $CURLOPTS -s -G -O $UPDATEURL/client/fauxide.tgz") == 0
	or errexit("Cannot download fauxide.tgz, verify your internet connection.");
    system ("tar xzf fauxide.tgz") == 0
	or errexit("fauxide.tgz seems to be corrupt, please delete and restart.");
    system ("rm -rf fauxide.tgz");
    system("rmmod fauxide 2> /dev/null");

    # If kernel is 2.6.x
    if( substr("$running_version", 0, 3) == "2.6" ) {
	system("cd fauxide; make DRIVER26; echo 'Running rmmod isr...'; /sbin/rmmod isr > /dev/null 2>&1; echo 'Moving isr.ko to /lib/modules...'; mv -f isr-driver-build/isr.ko /lib/modules/$running_version/misc/; echo 'Running depmod...'; /sbin/depmod -a; echo 'running modprobe...'; /sbin/modprobe isr; cd ..; rm -rf fauxide");
	system("echo 'alias block-major-242 isr' >> /etc/modprobe.conf");
    }
    # If kernel is 2.4.x
    else {
	system("cd fauxide; make clean >> /dev/null; make fauxide.o; echo 'Moving fauxide.o to /lib/modules'; mv -f fauxide.o /lib/modules/$running_version/misc/fauxide.o; make vulpes >> /dev/null 2>&1; mv -f vulpes $ISRCLIENTBINDIR/; cd ..; rm -rf fauxide");
	system("echo 'alias block-major-242 fauxide' >> /etc/modules.conf");
    }  
}

#
# Add ISRCLIENTBIN to the PATH
#
if ($command ne "update") {
    print BLUE, "Adding [$ISRCLIENTBINDIR] to [\$PATH] for [isruser]...\n", RESET;
    open (OUTFILE, ">>/home/isruser/.bashrc")
	or errexit("Unable to open /home/isruser/.bashrc.");
    print OUTFILE "\nexport PATH=\$PATH:$ISRCLIENTBINDIR\n"; 
    close(OUTFILE);
}

#
# Set ownership of isr data and programs
#
if ($command eq "client") {
    print BLUE, "Setting ownership and permissions...\n", RESET;

    system("chmod 644 $ISRMANDIR/isr.1");
    system("chmod 755 /etc/init.d/vulpes_stop");
    system("chown -R isruser:isrgroup /usr/local/isr");
    system("chown -R isruser:isrgroup /home/isruser");
    system("chown root:root $ISRMANDIR/isr.1");
    system("chown -R isruser:isrgroup /dev/hdk*");
}


if ($command eq "nsrv" or $command eq "srv") {
    print BLUE, "Setting ownership and permissions...\n", RESET;

    system("chmod 755 $ISRSERVERBINDIR/*");
    system("chmod 644 $ISRSERVERBINDIR/Server.pm");
}

if ($command eq "client" or $command eq "update") {
    system("chmod 644 $ISRCLIENTBINDIR/Isr.pm");
    system("chmod 644 $ISRCLIENTBINDIR/VERSION");
    system("chmod 644 $ISRCLIENTBINDIR/README");
    system("chmod 644 $ISRCLIENTBINDIR/HTTPSSH.pm");
    system("chmod 644 $ISRCLIENTBINDIR/CODA.pm");
    system("chmod 644 $ISRCLIENTBINDIR/.hostid");
    system("chmod 755 $ISRCLIENTBINDIR/vulpes");
    system("chmod 755 $ISRCLIENTBINDIR/isr");
    system("chmod 755 $ISRCLIENTBINDIR/isr_gui");
}
 
#
# Print further instructions
#
print "\n";

if ($command eq "client") {
    print RED, "Now logout of this machine, login as [isruser/changeme], and do the following:\n", RESET;
    print RED, "   Start VMware and enter an appropriate serial number.\n", RESET;
    print RED, "   Edit the entries in $ISRCLIENTBINDIR/Isr.pm (if applicable)\n\n", RESET;
    print GREEN, "Success: Client setup completed.\n\n", RESET;
}

elsif ($command eq "nsrv") {
    print RED, "Be sure to confirm the entries in $ISRSERVERBINDIR/Server.pm\n\n", RESET;
    print GREEN, "Success: Name server setup completed.\n\n", RESET;
}

elsif ($command eq "srv") {
    print RED, "Be sure to confirm the entries in $ISRSERVERBINDIR/Server.pm\n\n", RESET;
    print GREEN, "Success: Content server setup completed.\n\n", RESET;
}

elsif ($command eq "update") {
    print GREEN, "Success: Client update completed.\n", RESET;
    print "\n";
}
exit 0;

#####################
# End of main routine
#####################

#
# errexit - Print an error message and exit
#
sub errexit ($) {
    my $msg = shift;
    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print RED, "[$progname] Error: $msg\n", RESET;
    exit 1;
}

#
# system_errexit - Print an error after the system() function fails
#
sub system_errexit ($) {
    my $msg = shift;

    my $exit_value = $? >> 8;
    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    # $? is the wait() style return value. $! is strerr[errno]
    # $exit_value  = $? >> 8;
    # $signal_num  = $? & 127;
    # $dumped_core = $? & 128;
    print RED, "[$progname] Error: $msg\n", RESET;
    message("ERROR", "[$progname] Error: $msg");
    message("EXIT", "$exit_value");

    # Pass the callee's exit value back to the caller
    exit $exit_value; 
}

#
# err - Print a warning message
#
sub err ($) {
    my $msg = shift;
    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print RED, "[$progname] Warning: $msg\n", RESET;
}

#
# usage - print a usage message and exit
#
sub usage ($) {
    my $msg = shift;
    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    if ($msg) {
        print RED, "Error: $msg\n", RESET;
    }

    print RED, "Usage: $progname cmd\n", RESET;
    print BLUE, "Commands:\n", RESET;
    print BLUE, "  help      Print this message.\n", RESET;
    print BLUE, "  clean     Removes all traces of ISR from this system (dangerous command).\n", RESET;
    print BLUE, "  client    Builds a functional ISR client.\n", RESET;
    print BLUE, "  user      creates a new member of isrgroup. (specify <username>)\n", RESET;
    print BLUE, "  srv       Builds an ISR HTTPSSH content server.\n", RESET;
    print BLUE, "  nsrv      Builds an ISR name server.\n", RESET;
    print BLUE, "  update    Triggers an update of the ISR Client software.\n", RESET;
    
    exit 0;
}    

