#!/usr/bin/perl
###################################################################
# isr - The ISR client program
###################################################################

#
# isr - Client user interface for the Internet Suspend/Resume (R) system
#
# Copyright (C) 2004-2007 Carnegie Mellon University
#
# This software is distributed under the terms of the Eclipse Public
# License, Version 1.0 which can be found in the file named LICENSE.Eclipse.
# ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES
# RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT
#

#####################
# Section 0: Prologue
#####################

use Sys::Hostname;
use Getopt::Long;
use IO::Socket;
use File::Path;
use File::Copy;
use File::stat;
use Term::ANSIColor qw(:constants);
use POSIX ":sys_wait_h";
use POSIX ":signal_h";
use Fcntl qw(:DEFAULT :seek);
use Errno qw(:POSIX);
use Config;
require "syscall.ph";
use lib "!!SHAREDIR!!";
use Isr;
use IsrConfigTie;
use IsrRevision;
use strict;
use warnings;

$| = 1; # Autoflush output on every print statement


# Function prototypes
sub checkout ($$$$);
sub run ($$$$);
sub checkin ($$$);
sub sync ($$$$);
sub discard ($$$);
sub disconnect ($$$$);
sub listparcels ($$$$$);
sub authenticate ($);
sub deauthenticate ();
sub passwd ($);
sub release ($$$);
sub clean ($$$$);
sub resetclient ();
sub cleanclient ($$$$);
sub hoard ($$$);
sub do_hoard ($$$);
sub checkparcel ($$$$$);
sub statparcel ($$$);
sub get_parcelcfg ($$$);
sub get_motd ($$);
sub parse_cfgfile ($$);
sub parse_parcelcfg ($$$);
sub build_cache ($$);
sub hdksize ($$$);
sub connected ();
sub check_nexus_version ();
sub get_dirnum ($$);
sub get_chunknum ($$);
sub get_parcelkeeper_pid ();
sub block_sigint ();
sub unblock_sigint ($);
sub block_sigtstp ();
sub mysystem ($);
sub sys_sync ();
sub mktree ($);
sub err ($);
sub unix_err ($);
sub errexit ($);
sub unix_errexit ($);
sub system_errexit ($);
sub system_err ($);
sub message ($$);
sub usage ($);
sub need_parcel ();
sub need_not_parcel ();
sub need_checked_out ();
sub need_network ();
sub acquire_lock ($$);
sub release_locks ();
sub exit_handler ($);

#########################
# Section 1. Main routine
#########################

# Local variables
my $isrdir;
my $isrhome;
my $result;
my $progname; 
my $unused;
my $prot;

# Command line arguments that are private to this module
my $disconnected;    # Run disconnected
my $longflag;        # Print default number of versions for ls long format
my $longvers;        # Print specific number of versions for ls long format
my $version;         # Rollback version
my $checkstate = 0;  # Optionally check content consistency in some cmds
my $noautoflag;      # Don't automatically start/stop VMware at launch time
my $allflag;         # "clean" should delete all state, including hoard cache

# Write once globals that are visible in this module only. These globals are
# needed to cleanly handle logging.
my $log_enabled = 0;# Is logging enabled?
my $pid;            # Pid of child created in mysystem
my $sessionid = 0;  # Unique session id (nonce from lock operation)
my $userid;         # ISR userid
my $command;        # isr subcommand

# State globals, visible in this module only, which track which cleanup actions
# will be necessary when we exit.
my $no_shutdown = 0;# Set by forked children so the child won't run END
my $kill_pk = 0;    # Set by run command, tells END handler to kill Parcelkeeper
my @locks;          # Names and FDs of open lock files

# Read-only command line arguments that are visible to other modules.
our $verbose = 1;   # Verbosity level; by default, we print a few messages
our $nocheckstate;  # Skip state  consistency check in ci, sync, disconnect
our $bwlimit;       # Bandwidth limit (KBytes/sec) in ci and sync
our $server;        # Server domain name
our $parcel;        # parcel name

#
# Read/write global variable: At any point in time, this hash contains
# the key/value pairs from the parcel.cfg for the current parcel. For
# each command except listparcels, %cfg is initialized exactly once, 
# and only by calls to parse_parcelcfg.  This variable is tied such that
# accesses to nonexistent keys will result in a call to errexit().
# XXX false!
#
our %cfg = ();

#
# Write-once global variable containing the key/value pairs from the
# global and per-user configuration files.  This variable is tied such that
# accesses to nonexistent keys will result in a call to errexit().
#
our %syscfg = ();

#####
# Some initialization steps
#

#
# Define what we do on shutdown (placed here for clarity)
#
sub exit_handler ($) {
    my $status = shift;
    
    my $pid;
    
    return if $no_shutdown;
    
    if ($kill_pk) {
	$pid = get_parcelkeeper_pid();
	if ($pid != 0) {
	    kill("TERM", $pid);
	    print("Sent shutdown signal to Parcelkeeper.\n")
		if $verbose;
	}
    }
    sys_sync();
    sys_sync();
    
    # Remove temporary files
    system("rm -f /tmp/*.$$");
    system("rm -rf $isrdir/tmplast*")
	if $isrdir;
    
    message("EXIT", $status);
    release_locks();
}

#
# Run the exit handler during normal termination
#
END {
    my $status=$?;
    exit_handler($status);
    $? = $status;
}

#
# Install a signal handler that catches ctrl-c
#
sub sigint_handler () {
    message("INFO", "Caught SIGINT");
    # Call the exit handler, then unregister the signal handler and send the
    # signal again (whereupon we will die).  This ensures that our exit status
    # properly reports that we were killed by a signal.
    exit_handler(-1);
    $SIG{"INT"} = 'DEFAULT';
    kill("INT", $$);
};

$SIG{"INT"} = \&sigint_handler;

#
# Parse config files
#

# This file must exist, since it provides our defaults
parse_cfgfile("$Isr::SHAREDIR/config", \%syscfg)
    or errexit("Can't read defaults file $Isr::SHAREDIR/config");
# These may not exist, but can override the earlier ones
parse_cfgfile("$Isr::SYSCONFDIR/openisr.conf", \%syscfg);
parse_cfgfile("$ENV{HOME}/.openisrrc", \%syscfg);

#
# Source HTTPSSH.pm
#
do "$Isr::SHAREDIR/HTTPSSH.pm"
    or errexit("Unable to load module HTTPSSH.pm");

#####
# Various defaults
#

#
# Check if the user is running as root
#
if ((getpwuid($<))[0] eq "root") {  # Reminder: '$<' is the UID 
    errexit("Root is not allowed to run the isr client program.");
}

# The default ISR userid is defined by $syscfg{userid}.
# If this is empty, then the default is the Unix login name.
# Override using the -u flag.
$userid = $syscfg{userid}
    if exists($syscfg{userid});
$userid = $ENV{USER}
    if (!$userid);

# Set the default server; may be overridden from command line
$server = $syscfg{server};

# Strip off pathname from the program name
($progname = $0) =~ s#.*/##s; # Strip off path from program name

#
# Handle the case where the user calls the program with no arguments
#
if (@ARGV == 0) {
    print("$progname: Try '$progname help' for more information.\n");
    exit 0;
}

#
# Parse the command line
#
Getopt::Long::Configure("no_ignore_case", "bundling_override",
			"no_getopt_compat");
$result = GetOptions(
		     "a|allstate"     => \$allflag,
		     "b|bwlimit=i"    => \$bwlimit,
		     "c|checkstate+"  => \$checkstate,
		     "x|nocheckstate" => \$nocheckstate,
		     "d|disconnected" => \$disconnected,
		     "l|long"         => \$longflag,
		     "L|longvers=i"   => \$longvers,
		     "q|quiet"        => sub { $verbose = 0 },
		     "r|rollback=i"   => \$version,
		     "s|server=s"     => \$server,
		     "u|user=s"       => \$userid,
		     "v|verbose+"     => \$verbose,
		     "X|noauto"       => \$noautoflag
		     );

if ($result == 0) {
    usage("Invalid option(s) specified");
}

#
# Extract the command name
#
if (@ARGV == 0) {
    usage("Missing command");
}
if (@ARGV > 2) {
    usage("Extraneous parameters on command line");
}
$command = $ARGV[0];
$parcel = $ARGV[1];

#
# Set the the directory where ISR parcels will be stored and if
# it doesn't yet exist, create an empty one.
#
$isrhome = "$ENV{HOME}/.isr";
$isrdir = "$isrhome/$userid";

if (!-e $isrhome) {
    mkdir($isrhome)
	or unix_errexit("Unable to make $isrhome");
}
if (!-e $isrdir) {
    mkdir($isrdir)
	or unix_errexit("Unable to make $isrdir");
}
if (!-d $isrdir) {
    errexit("$isrdir is not a directory");
}

#
#
# Assign aliases
#
if ($command eq "ci") {
    $command = "checkin"
}
if ($command eq "co") {
    $command = "checkout"
}
if ($command eq "checkp") {
    $command = "checkparcel"
}


#####
# Process the command
#

#
# Set the session ID to the nonce value if the parcel is 
# checked out, zero otherwise.
#
$sessionid = 0;
if ($parcel && -e "$isrdir/$parcel/nonce" && open(NONCE, "$isrdir/$parcel/nonce")) {
    $sessionid = <NONCE>;
    close(NONCE);
    chomp($sessionid);
}

#
# Now process the ISR command. Notice that most commands take the same three
# args (userid, parcel, isrdir), followed by one or more optional args.
#

# Basic commands
if ($command eq "checkout") {
    need_parcel();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    checkout($userid, $parcel, $isrdir, $version);
} 
elsif ($command eq "resume") {
    need_parcel();
    # Resume will need a network connection if the requested parcel is not
    # currently checked out, or if the parcel is checked out and we're not
    # planning on running disconnected.
    need_network()
	if ((!-e "$isrdir/$parcel") or
	    (-e "$isrdir/$parcel" and !$disconnected));
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    checkout($userid, $parcel, $isrdir, $version);
    run($userid, $parcel, $isrdir, $disconnected);
} 
elsif ($command eq "checkin") {
    need_parcel();
    need_checked_out();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    checkin($userid, $parcel, $isrdir);
} 
elsif ($command eq "sync") {
    need_parcel();
    need_checked_out();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    sync($userid, $parcel, $isrdir, 0);
} 
elsif ($command eq "discard") {
    need_parcel();
    need_checked_out();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    discard($userid, $parcel, $isrdir);
}
elsif ($command eq "hoard") {
    need_parcel();
    acquire_lock("$isrdir/$parcel-hoard.lock", "Hoard cache");
    hoard($userid, $parcel, $isrdir);
}
elsif ($command eq "stat") {
    need_parcel();
    need_checked_out();
    acquire_lock("$isrdir/$parcel.lock", "Parcel")
	if $checkstate;
    statparcel($userid, $parcel, $isrdir);
}
elsif ($command eq "disconnect") {
    need_parcel();
    need_checked_out();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel")
	if (!$nocheckstate);
    acquire_lock("$isrdir/$parcel-hoard.lock", "Hoard cache");
    disconnect($userid, $parcel, $isrdir, $nocheckstate);
}
elsif ($command eq "checkparcel") {
    need_parcel();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    checkparcel($userid, $parcel, $isrdir, $version, $checkstate);
}
elsif ($command eq "ls") {
    need_network();
    listparcels($userid, $parcel, $isrdir, $longflag, $longvers);
}
elsif ($command eq "auth") {
    need_not_parcel();
    need_network();
    authenticate($userid);
}
elsif ($command eq "deauth") {
    need_not_parcel();
    deauthenticate();
}
elsif ($command eq "passwd") {
    need_not_parcel();
    need_network();
    passwd($userid);
}
elsif ($command eq "reset") {
    need_not_parcel();
    resetclient();
}
elsif ($command eq "clean") {
    need_parcel();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    acquire_lock("$isrdir/$parcel-hoard.lock", "Hoard cache")
	if $allflag;
    cleanclient($userid, $parcel, $isrdir, $allflag);
}
elsif ($command eq "help") {
    need_not_parcel();
    usage("");
}
elsif ($command eq "version") {
    need_not_parcel();
    # These are the copyrights for the entire OpenISR client codebase, not
    # just the user interface.
    print <<END;
OpenISR !!VERSION!!, client revision $Isr::RCS_REVISION

Copyright (C) 2000-2007 Carnegie Mellon University and others
The OpenISR system comes with ABSOLUTELY NO WARRANTY.  Different parts of
this software are distributed under different licenses, including the
Eclipse Public License, version 1.0; the GNU General Public License, version 2;
and the GNU Lesser General Public License, version 2.1.  See the README file
included with this software for details on which license applies to each
component of the OpenISR system.
END
    exit 0;
}
# Everything else
else {
    usage("$command is an invalid command.");
}    

#
# Clean up and exit
#
message("END", $command);
exit 0;


##########################################
# Section 2. Definition of client commands
##########################################

#
# checkout - Lock a parcel and copy it from the server to the client
#
sub checkout ($$$$) {
    my $userid = shift;     # login name
    my $parcel = shift;     # parcel name
    my $isrdir = shift;     # absolute path of local ISR home dir
    my $version = shift;    # rollback version (optional)

    my $parceldir = "$isrdir/$parcel";
    my $hoarddir = "$isrdir/$parcel-hoard";
    my $lastdir = "$parceldir/last";
    my $diskinfo = `df -P -k $isrhome | tail -n 1`;
    my ($diskpartition, $diskblocks, $diskused, $diskspace, $diskpercent, $diskroot) = split(" ", $diskinfo);

    my $retval;
    my $target;
    my $cfgsize;
    my $tmpfile;
    my $cfg_sha1value;
    my $key_sha1value;
    my $cfg_file;
    my $key_file;
    my $clientname = hostname();
    my $sigset;
    my %map;

    # If the parcel is already checked out on this machine, return immediately
    if (-e $parceldir) {
	print(GREEN, "Success: Parcel $userid/$parcel already checked out on this host. Ready to run.\n", RESET)
	    if $verbose;
	return;
    }
    
    # Fetch and print message-of-the-day from the server
    print "Connecting to server.\n"
    	if $verbose;
    get_motd($userid, $parcel);

    # Fetch and parse the config file from the server
    print "Fetching configuration data for $userid/$parcel from server.\n"
	if $verbose;
    get_parcelcfg($userid, $parcel, "$isrdir/$parcel-parcel.cfg");
    %cfg = parse_parcelcfg("$isrdir/$parcel-parcel.cfg", $userid, $parcel);

    # Before going any further, make sure we have a protocol level
    # connection to the server and a consistent parcel.
    if (!isr_connected_http()) {
	errexit("The server appears to be down.");
    }
    if (!isr_connected_parcel($userid, $parcel)) {
	errexit("The remote parcel is not available.");
    }

    # Confirm that there is enough disk space.
    if ($diskspace < $cfg{MAXKB}) {
	errexit("Not enough disk space [$diskspace/$cfg{MAXKB} KB available]");
    }

    # From this point on, the operation should not be interrupted by the user
    $sigset = block_sigint();

    # Grab the lock from the server
    print("Acquiring lock from server.\n")
	if $verbose;

    if (isr_srun($userid, "lock", 
		 "-p $userid/$parcel -n $clientname -a", 
		 "$isrdir/$parcel-nonce", 0) != 0) {
	unlink("$isrdir/$parcel-nonce");
	errexit("Unable to acquire lock for $parcel.");
    }

    # Use the nonce from the lock operation as the unique session id
    if (-e "$isrdir/$parcel-nonce" && open(NONCE, "$isrdir/$parcel-nonce")) {
	$sessionid = <NONCE>;
	close(NONCE);
	chomp($sessionid);
    }

    # If requested, roll back to a previous version on the server
    if ($version) {
	if ($version < 1) {
	    clean($userid, $parcel, $isrdir, 0);
	    errexit("Version numbers must be greater than zero.");
	}
	print("Rolling back to version $version.\n")
	    if $verbose;
	if (isr_srun($userid, "rollback", 
		     "-u $userid -p $parcel -v $version", "", 0) != 0) {
	    clean($userid, $parcel, $isrdir, 0);
	    errexit("Unable to roll back to version $version");
	}
    }

    # Set up the client's parcel directory. If anything goes wrong erase 
    # all traces of the parcel on the client and release its lock.
    if (!mktree($parceldir)) {
	clean($userid, $parcel, $isrdir, 0);
	errexit("Unable to create parcel dir $parceldir.");
    }
    if (!mktree($lastdir)) {
	clean($userid, $parcel, $isrdir, 0);
	errexit("Unable to create last dir $lastdir.");
    }

    if (!rename("$isrdir/$parcel-nonce", "$parceldir/nonce")) {
	clean($userid, $parcel, $isrdir, 0);
	errexit("Unable to move $isrdir/$parcel-nonce to $parceldir");
    }
    if (!rename("$isrdir/$parcel-parcel.cfg", "$parceldir/parcel.cfg") != 0) {
	clean($userid, $parcel, $isrdir, 0);
	errexit("Unable to move $isrdir/$parcel-parcel.cfg to $parceldir");
    }

    #
    # Save the keyroot in the parcel directory (otherwise we would
    # need to include the actual keyroot on the command line)
    #
    open(KEYROOT, ">$lastdir/keyroot") 
	or errexit("Unable to open $lastdir/keyroot for writing");
    print KEYROOT "$cfg{KEYROOT}";
    close(KEYROOT);

    #
    # Fetch the parcel's virtualization files from the server
    #
    $tmpfile = "/tmp/stat.$$";
    if (isr_srun($userid, "stat", 
		 "-f $userid/$parcel/last/cfg.tgz.enc",
		 $tmpfile ,0) != 0) {
	unlink($tmpfile);
	clean($userid, $parcel, $isrdir, 0);
	errexit("Unable to stat cfg.tgz.enc file on server");
    }
    parse_cfgfile($tmpfile, \%map);
    unlink($tmpfile);
    $cfgsize = $map{SIZE};
    $cfg_sha1value = $map{SHA1};

    $tmpfile = "/tmp/stat2.$$";
    if (isr_srun($userid, "stat", 
		 "-f $userid/$parcel/last/keyring.enc",
		 $tmpfile ,0) != 0) {
	unlink($tmpfile);
	clean($userid, $parcel, $isrdir, 0);
	errexit("Unable to stat keyring.enc file on server");
    }
    %map = ();
    parse_cfgfile($tmpfile, \%map);
    unlink($tmpfile);
    $key_sha1value = $map{SHA1};

    #
    # Look aside to see if the memory image and/or keyring is available 
    #
    printf("Fetching virtual machine memory image (%d MB)...\n", int($cfgsize/(1<<20)))
	if $verbose;

    # XXX
#    if (-e "$hoarddir/$cfg_sha1value") {
#	print "Found local match for encrypted memory image.\n"
#	    if $verbose;
#	$cfg_file = "$hoarddir/$cfg_sha1value";
#    }

#    if (-e "$hoarddir/$key_sha1value") {
#	print "Found local match for encrypted keyring.\n"
#	    if $verbose;
#	$key_file = "$hoarddir/$key_sha1value";
#    }    

    #
    # Fetch the memory and meta files to a temp file and then commit.
    # isr_sget() will block SIGINT while curl runs, but will return
    # $Isr::EINTR if curl itself dies on a signal.  In order to let
    # this work, we unblock SIGINT and install a dummy signal handler
    # for the duration of this loop so that curl doesn't end up
    # blocking or ignoring SIGINT as well.  This means we lose SIGINTs
    # which are pending from before this loop.
    #
    unlink("$lastdir/tmpfile");
    $SIG{'INT'} = sub {};
    unblock_sigint($sigset);
    foreach $target ("keyring.enc", "cfg.tgz.enc") {
	next if ($target eq "keyring.enc" && $key_file);
	next if ($target eq "cfg.tgz.enc" && $cfg_file);
	
	print "Fetching $target...\n"
	    if ($verbose > 1);

	# Show a progress meter only for the big cfg file
	$retval = isr_sget($userid, "last/$target", "$lastdir/tmpfile",
			    ($target eq "cfg.tgz.enc"));
	if ($retval == $Isr::EINTR) {
	    print "\n";
	    # We now have an inconsistent parcel directory.  Blow it away
	    # and release the server lock.
	    clean($userid, $parcel, $isrdir, $sessionid);
	    errexit("Fetch interrupted by signal");
	}
	$retval == $Isr::ESUCCESS
	    or errexit("Unable to fetch $target file");
	rename("$lastdir/tmpfile", "$lastdir/$target")
	    or unix_errexit("Unable to commit $lastdir/$target");
    }
    $sigset = block_sigint();
    $SIG{'INT'} = \&sigint_handler;
    
    #
    # Decrypt and unpack the virtualization and Parcelkeeper files
    #
    print("Decrypting and uncompressing virtual machine memory image...\n")
	if $verbose;
    $key_file = "$lastdir/keyring.enc"
    	if !$key_file;
    $cfg_file = "$lastdir/cfg.tgz.enc"
    	if !$cfg_file;
    if (mysystem("openssl enc -d -aes-128-cbc -in $key_file -out $lastdir/keyring -pass file:$lastdir/keyroot -salt") != 0) {
	errexit("Could not decrypt keyring.enc");
    }
    if (mysystem("pv -peW -s $cfgsize $cfg_file | openssl enc -d -aes-128-cbc -pass file:$lastdir/keyroot -salt | tar xz --directory $lastdir") != 0) {
	errexit("Could not decrypt and unpack cfg.tgz.enc");
    }
    # Keyroot no longer needed, get rid of it
    foreach $target ("keyring.enc", "cfg.tgz.enc", "keyroot") {
	if (-e "$lastdir/$target" && !unlink("$lastdir/$target")) {
	    clean($userid, $parcel, $isrdir, 0);
	    errexit("Unable to remove $target.");
	}
    }

    # Clean up and return
    sys_sync();
    print(GREEN, "Success: Parcel $userid/$parcel now checked out (and lock acquired).\n", RESET)
	if $verbose;
    unblock_sigint($sigset);
    return;
}

#
# run - Execute a parcel on the client
#
sub run ($$$$) {
    my $userid = shift;       # login name
    my $parcel = shift;       # parcel name
    my $isrdir = shift;       # absolute path of user's local ISR home dir
    my $disconnected = shift; # true if we want to run disconnected 

    my $target;
    my @files;
    my $dirname;
    my $cfgfile;  # VMware configuration file
    my $numfiles;
    my $numchunks;
    my $i;
    my $iters;
    my $sigset;
    my $vmware_opts;
    my $pk_pid;
    my $devnode;
    
    my $parceldir = "$isrdir/$parcel";
    my $lastdir = "$parceldir/last";
    my $cachedir = "$parceldir/cache";
    my $pkcmd = "$Isr::LIBDIR/parcelkeeper";
    my $cdcache_file = "$parceldir/$Isr::CONSISTENT_DIRTYCACHE_FILE";

    # Block receipt of the SIGTSTP (ctrl-z)
    block_sigtstp();

    # Reset the consistent dirty cache flag, since any temporary dirty
    # cache directory is about to become inconsistent with the local cache.
    unlink($cdcache_file);

    # Parse the parcel config file that we got from the server during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg", $userid, $parcel);

    # If the user wants to run connected, then before going any further, 
    # make sure we have a protocol level connection to the server
    # and a consistent parcel.
    if (!$disconnected and !isr_connected_http()) {
	errexit("The server appears to be down.");
    }
    if (!$disconnected and !isr_connected_parcel($userid, $parcel)) {
	errexit("The remote parcel is not available.");
    }

    # Make sure that Parcelkeeper is where we expect it to be, that Nexus is
    # loaded, and that the control device exists.  Also, warn if the Nexus
    # release is older than our own release.
    if (!-e $pkcmd or !-x $pkcmd ) {
	errexit("Could not find an executable Parcelkeeper binary.");
    }
    if (!-d "/sys/class/openisr") {
        errexit("The OpenISR kernel module does not appear to be loaded.");
    }
    if (!-e "/dev/openisrctl") {
        errexit("Nexus control device does not exist");
    }
    check_nexus_version();

    # If the user wants to run disconnected, they better have all of their
    # disk blocks hoarded in the local or hoard cache
    if ($disconnected) {
	$numchunks = hdksize($userid, $parcel, $isrdir); 

	# If the local cache is not fully populated, then make sure
	# the hoard cache is fully populated
	if ($numchunks != $cfg{NUMCHUNKS}) {
	    if (isr_stathoard($userid, $parcel, $isrdir) != $cfg{NUMCHUNKS}) {
		errexit("Running disconnected without a fully hoarded parcel.\nPlease run \"isr disconnect $parcel\" first.");
	    }
	}
	print("Running disconnected...\n")
	    if $verbose;
    }

    # Create a Parcelkeeper cache if one doesn't already exist
    # This operation must not be interrupted by the user
    print("Initializing local cache.\n")
	if $verbose;

    $sigset = block_sigint();
    build_cache($cachedir, $lastdir);
    unblock_sigint($sigset);

    # Make sure there is exactly one VMware config file
    opendir(DIR, "$cachedir/cfg")
	or unix_errexit("Unable to open $cachedir/cfg");
    @files = grep(/\.vmx$/, readdir(DIR));
    closedir(DIR);
    $numfiles = @files;
    if ($numfiles != 1) {
	errexit("Found $numfiles virtual machine config files, but expected exactly one.");
    }
    $cfgfile = $files[0];
    
    # Launch Parcelkeeper. 
    print("Launching Parcelkeeper...\n")
	if $verbose;
    $kill_pk = 1;  # Tells the SIGINT handler to cleanly terminate PK
    isr_run_parcelkeeper($userid, $parceldir, $disconnected) == 0
	or errexit("Unable to launch Parcelkeeper.");	
    
    # Find out what device node we'll be using
    open(DEVFILE, "$cachedir/parcelkeeper.dev")
    	or unix_errexit("Can't open $cachedir/parcelkeeper.dev");
    chomp($devnode = <DEVFILE>);
    close(DEVFILE);
    message("INFO", "Using device node $devnode");
    
    # Wait for udev to catch up
    $iters = 0;
    while (1) {
	# Get Parcelkeeper pid and make sure it's still alive
	$pk_pid = get_parcelkeeper_pid();
	if ($pk_pid == 0) {
	    errexit("Parcelkeeper died unexpectedly");
	}
	last if -e $devnode;
	# Sleep 100 ms
	select(undef, undef, undef, 0.1);
	# Give up after 15 s
	errexit("Timed out waiting for creation of device node $devnode")
	    if (++$iters == 150);
    };

    # Launch VMware
    print "Launching VMware...\n"
	if $verbose;
    if (!$noautoflag) {
        $vmware_opts = "-X";
    } else {
        $vmware_opts = "";
    }
    mysystem("LD_PRELOAD=libvdisk.so.0 VDISK_DEVICE=$devnode $syscfg{vmcommand} $vmware_opts $cachedir/cfg/$cfgfile") == 0
	or system_errexit("VMware terminated abnormally.");

    # Wait here until the user suspends VMware
    print "Shutting down VMware.\n"
	if $verbose;
    
    # Signal Parcelkeeper to shut down and wait until it is gone
    print "Shutting down Parcelkeeper (pid=$pk_pid)"
	if $verbose;
    kill("TERM", $pk_pid);
    $kill_pk = 0;
    message("INFO", "Sent SIGTERM signal to Parcelkeeper (pid=$pk_pid)");
    $iters = 0;
    while (1) {
	if (++$iters > 60) {
	    print "\n";
	    errexit("Unable to shutdown Parcelkeeper");
	}
	print "."
	    if $verbose;
	last
	    if get_parcelkeeper_pid() == 0;
	sleep(1);
    }
    print "\n"
	if $verbose;
}

#
# checkin - Sync and then release parcel
#
sub checkin ($$$) {
    my $userid = shift;     # login name
    my $parcel = shift;     # parcel name
    my $isrdir = shift;     # absolute path of local ISR home dir

    my $parceldir = "$isrdir/$parcel";

    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg", $userid, $parcel);

    # Sync the dirty blocks on the server
    sync($userid, $parcel, $isrdir, 1) == $Isr::ESUCCESS
	or errexit("Sync of parcel $userid/$parcel failed.");

    # Release the lock on the parcel
    release($userid, $parcel, $isrdir) == $Isr::ESUCCESS
	or errexit("Release of parcel $userid/$parcel failed.");
}

#
# sync - Make local state clean
#
sub sync ($$$$) {
    my $userid = shift;     # login name
    my $parcel = shift;     # parcel name
    my $isrdir = shift;     # absolute path of local ISR home dir
    my $releasing = shift;  # whether we're releasing the lock afterward

    my $parceldir = "$isrdir/$parcel";
    my $relstring = "";
    my $vflag = "-q";
    my $bwflag = "";
    my $i;

    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg", $userid, $parcel);

    # Now call the protocol-specific sync function
    isr_sync($userid, $parcel, $isrdir, $releasing) == $Isr::ESUCCESS
	or errexit("Sync of parcel $userid/$parcel failed.");
    
    # Append the session log to the persistent log in remote storage
    # and if successful delete the session log. 
    message("INFO", "Uploading session log");
    print "Uploading session log...\n"
	if $verbose;

    $vflag = "--progress"
	if ($verbose);
    $bwflag = "--bwlimit=$bwlimit"
	if ($bwlimit);

    # Retry if the put operation fails
    for ($i = 0; $i < $syscfg{retries}; $i++) {
	if (mysystem("rsync -e ssh --partial -z $vflag $bwflag $isrdir/$parcel.log $userid\@$main::cfg{WPATH}/session.log.new") == 0) {
	    if (isr_srun($userid, "catlog", "-u $userid -p $parcel -f session.log.new", "", 0) == 0) {
		unlink("$isrdir/$parcel.log");
		last;
	    }
	}
	print "[isr] put operation failed. Retrying...\n"
	    if $main::verbose;
    }
    
    $relstring = " (but not released)"
	if !$releasing;
    print(GREEN, "Success: Sync completed. Parcel checkpointed$relstring.\n", RESET)
	if $verbose;

    return $Isr::ESUCCESS;
}

#
# upload - Upload the contents of the local cache to the server (DEBUG only)
#
sub upload ($$$) {
    my $userid = shift;     # login name
    my $parcel = shift;     # parcel name
    my $isrdir = shift;     # absolute path of local ISR home dir

    my $parceldir = "$isrdir/$parcel";

    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg", $userid, $parcel);

    # Now call the protocol-specific sync function
    isr_priv_upload($userid, $parcel, $isrdir);
    
    return $Isr::ESUCCESS;
}

#
# discard - Remove the Parcelkeeper cache
#
sub discard ($$$) {
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift;

    my $reply;
    my $parceldir = "$isrdir/$parcel";
    my $cachedir = "$parceldir/cache";
    my $cdcache_file = "$parceldir/$Isr::CONSISTENT_DIRTYCACHE_FILE";

    # Give users a chance to change their minds.
    if ($verbose) {
	$reply = query("This command deletes local session state on this host. Proceed?");
	if ($reply eq "n") {
	    return;
	}
    }

    # This operation should not be interrupted by the user
    block_sigint();

    # Delete the local cache
    if (-e $cachedir) {
	mysystem("rm -rf $cachedir");
    }

    #
    # Reset the consistent dirty cache flag, since any temporary dirty
    # cache directory can no longer be consistent with an empty local cache.
    #
    unlink($cdcache_file);

    print(GREEN, "Success: Local changes to parcel $userid/$parcel discarded.\n", RESET)
	if $verbose;

}

#
# disconnect - Prepare the host to disconnect from a parcel
#
sub disconnect ($$$$) {
    my $userid = shift;       # login name
    my $parcel = shift;       # parcel name
    my $isrdir = shift;       # absolute path of local ISR home dir
    my $nocheckstate = shift; # optionally skip consistency check

    my $parceldir = "$isrdir/$parcel";
    my $lastdir = "$parceldir/last";
    my $cachedir = "$parceldir/cache";
    
    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg", $userid, $parcel);

    print "Preparing client host to run parcel $userid/$parcel disconnected...\n";
    
    if (!$nocheckstate) {
	print "Hint: Use the -x option to skip the lengthy consistency check.\n";
    }


    # Hoard the parcel if it's not already hoarded
    if (isr_stathoard($userid, $parcel, $isrdir) < $cfg{NUMCHUNKS}) {
	do_hoard($userid, $parcel, $isrdir);
    }

    # Optionally check the hoard cache for consistency
    if (!$nocheckstate) {
	isr_checkhoard($userid, $parcel, $isrdir, 1, 0);
    }

    # Print the appropriate success message
    if (!$nocheckstate) {
	print(GREEN, "Success: You can safely run disconnected.\n", RESET)
	    if $verbose;
    }
    else {
	print(GREEN, "Success: You can now run disconnected.\n", RESET)
	    if $verbose;
    }
}

#
# listparcels - list information about a user's parcels
#
sub listparcels ($$$$$) {
    my $userid = shift;      # login name
    my $parcelname = shift;  # parcel name (all parcels if undefined or "")
    my $isrdir = shift;      
    my $longflag = shift;    # use default # of versions for long ls format
    my $longvers = shift;    # use specific # of versions for long ls format

    my $line;
    my $item;
    my $lsargs;
    
    # Build the argument list for the server-side ls operation
    $lsargs = "";
    if ($parcelname) {
	$lsargs = "-p $parcelname";
    }
    if ($longvers) {
	$lsargs .= " -L $longvers";
    } elsif ($longflag) {
	$lsargs .= " -L $syscfg{ls_versions}";
    }

    # Run the remote ls program on the server.  Pass through server
    # errors without further comment.
    print "Parcels for $userid on server $server:\n";
    isr_srun($userid, "ls", "-u $userid $lsargs", "", 0);
}

#
# authenticate - Perform the SSH magic
#
sub authenticate ($) {
    my $userid = shift;

    mysystem("ssh -A -l $userid $server ssh-add") == 0
	or system_errexit("Unable to run ssh-add on the server ($server)");

    return 0;
}

#
# deauthenticate - Remove all SSH keys
#
sub deauthenticate () {

    mysystem("ssh-add -D") == 0
	or system_errexit("Unable to run \"ssh-add -D\" on local machine");

    return 0;
}

#
# release - Erase all traces of a parcel from the client and do a 
#           soft release (i.e., with nonce) of its lock.
#
sub release ($$$) {
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift; 

    my $nonce;

    my $parceldir = "$isrdir/$parcel";

    # This operation should not be interrupted by the user
    block_sigint();

    # Get the nonce
    if (!-e "$parceldir/nonce") {
	errexit("$parceldir/nonce does not exist.");
    }
    open(NONCE, "$parceldir/nonce")
        or errexit("Can't read $parceldir/nonce");
    $nonce = <NONCE>;
    close(NONCE);
    chomp($nonce);
    if (!$nonce) {
	err("Empty client nonce\n");
    }

    # Release the lock on the parcel using the nonce (soft release)
    print "Releasing parcel lock...\n"
	if $verbose;
    if (clean($userid, $parcel, $isrdir, $nonce) == 0) {
	print(GREEN, "Success: Parcel $userid/$parcel is now checked in (and lock released).\n", RESET)
	    if $verbose;
    }

    return 0;
}

#
# hoard - Copy all server disk blocks to the local client cache
#
sub hoard ($$$) {
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift;

    my $parcelcfgfile; 

    my $parceldir = "$isrdir/$parcel";

    # If the parcel is not currently checked out, then fetch a
    # temporary copy of parcel.cfg from the server, otherwise use
    # the parcel.cfg file hat was fetched during checkout

    $parcelcfgfile = "$parceldir/parcel.cfg";
    if (!-e $parceldir) {
	$parcelcfgfile = "$isrdir/$parcel-parcel.cfg.hoard";
	print "Fetching configuration data for $userid/$parcel from server.\n"
	    if $verbose;
	get_parcelcfg($userid, $parcel, $parcelcfgfile);
    } 

    # Parse the config file
    %cfg = parse_parcelcfg($parcelcfgfile, $userid, $parcel);

    # Delete the temporary parcel.cfg file if necessary
    if (!-e $parceldir) {
	unlink($parcelcfgfile);
    }

    # Run the actual hoard process
    do_hoard($userid, $parcel, $isrdir);

    # The hoard finished without any errors. Declare success
    print GREEN, "Success: The parcel $userid/$parcel is now fully hoarded on this host.\n", RESET
	if $verbose;
}

#
# checkparcel - Check a remote parcel for consistency
#
sub checkparcel ($$$$$) {
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift;
    my $version = shift;
    my $checkstate = shift;

    my $versionflag;
    my $checkstateflag;
    
    my $parceldir = "$isrdir/$parcel";

    #
    # Ask the server the to check the consistency of the parcel
    #
    $versionflag = "";
    if ($version) {
	$versionflag = "-v $version";
    }

    $checkstateflag = "";
    if ($checkstate) {
	$checkstateflag = "-c";
    }
    isr_srun($userid,
	     "checkparcel", 
	     "-u $userid -p $parcel -V $versionflag $checkstateflag",
	     "", 0) == 0
		 or errexit("There is something wrong with parcel $userid/$parcel on the server.");

    print(GREEN, "Success: The parcel $userid/$parcel on the server looks OK.\n", RESET)
	if $verbose;
}

#
# statparcel - Report general statistics about the cache and if requested, 
#              run a content consistency check on the chunks
#
sub statparcel ($$$) {
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift;

    my $parceldir = "$isrdir/$parcel";

    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg", $userid, $parcel);

    isr_statparcel($userid, $parcel, $isrdir, $checkstate);
}

#
# passwd - Change the user's ISR passwd on the server
#
sub passwd ($) {
    my $userid = shift;

    print "Changing password for ISR userid $userid:\n";
    mysystem("ssh -l $userid -t $server passwd") == 0
	or errexit("Unable to change ISR password.");
}

#
# resetclient - Resets the ISR runtime
#
sub resetclient () {
    my $vmname;
    my $vmopts;
    
    query("Really terminate all running ISR processes?") eq "y"
	or return;

    print("Terminating any Parcelkeeper processes.\n")
	if $verbose;
    system("killall parcelkeeper > /dev/null 2>&1");

    print("Terminating any VMware processes.\n")
	if $verbose;
    ($vmname, $vmopts) = split(" ", $syscfg{vmcommand});
    system("killall $vmname > /dev/null 2>&1");

    print("Terminating any ISR processes.\n")
	if $verbose;
    system("killall isr > /dev/null 2>&1");
}

#
# cleanclient - Remove all traces of a parcel's session state
#
sub cleanclient($$$$) {    
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift;
    my $allflag = shift;

    my $reply;
    my $hoarddir = "$isrdir/$parcel-hoard";

    # Give users a chance to change their minds.
    if ($verbose) {
	$reply = query("This command deletes local session state on this host. Proceed?");
	if ($reply eq "n") {
	    return;
	}
    }

    # Remove the parcel's session state
    print("Removing session state and releasing server lock...\n")
	if $verbose;
    if (clean($userid, $parcel, $isrdir, 0) > 0) {
	return;
    }

    # Optionally remove the parcel's hoard cache, too
    if ($allflag) {
	print("Deleting hoard cache...\n")
	    if $verbose;
	system("rm -rf $hoarddir > /dev/null 2>&1");
    }

    print(GREEN, "Success: Parcel $userid/$parcel erased from client and server lock released.\n", RESET)
	if $verbose;
}

#############################
# Section 3. Helper functions
#############################

#####
# Subcommand sanity checks
#

#
# Most commands require a parcel on the command line
#
sub need_parcel () {
    usage("Missing parcel name")
	if !$parcel;
    
    # 
    # Hack: the cases in which we need a parcel name are exactly the cases
    # in which we want to log.  (If we don't have a parcel name, we don't know
    # what log file to write to.)  So we start the log as a side-effect.
    #
    $log_enabled = 1;
    message("START", "OpenISR !!VERSION!!, revision $Isr::RCS_REVISION");
    message("ENTER", "@ARGV");
    message("BEGIN", $command);
}

#
# Some commands don't work on a particular parcel
#
sub need_not_parcel () {
    usage("\"$command\" does not take a parcel name")
	if $parcel;
}

#
# Some commands expect the parcel to already be checked out
#
sub need_checked_out () {
    errexit("Parcel $userid/$parcel not checked out. Checkout or resume first.")
	if (!-e "$isrdir/$parcel");
}

#
# Most commands require a network connection
#
sub need_network () {
     print "Checking network connection...\n"
	 if $verbose > 1;
     connected() 
	 or errexit("You do not appear to have a network connection: couldn't contact $server.");
}

#####
# Misc helper functions
# 

sub acquire_lock ($$) {
    my $file = shift;
    my $desc = shift;
    
    my $lockstruct;
    my $fh;
    
    # This is black magic.  We don't want to make assumptions about whether
    # we're using off_t or off64_t, or whether we're on a 64-bit architecture,
    # or whether Perl is compiled to support 64-bit ints (so we can't use
    # the "q" template flag).  Fortunately, we need to set both l_start
    # and l_len to zero, and there's nothing after that whose alignment
    # we care about.  So we just pad to the largest possible case, which
    # is off64_t, in 32-bit chunks.  We do, however, still make assumptions
    # about the ordering of the fields in the struct; there doesn't seem to
    # be any way around that.
    $lockstruct = pack("s!s!lllll", F_WRLCK, SEEK_SET);
    open($fh, ">", $file)
	or unix_errexit("Can't open $file for writing");
    if (!fcntl($fh, F_SETLK, $lockstruct)) {
	errexit("$desc locked by another process")
	    if ($! == EACCES or $! == EAGAIN);
	unix_errexit("Can't acquire lock");
    }
    push(@locks, {"NAME" => $file, "FH" => $fh});
}

sub release_locks () {
    my $record;
    
    while ($record = pop(@locks)) {
	unlink($record->{"NAME"});
	close($record->{"FH"});
    }
}

#
# clean - Erase all traces of a parcel from the client and do a soft
#         (with nonce) or hard (no nonce) release of its lock.
#
sub clean ($$$$) {
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift;
    my $nonce = shift;     # nonce (optional)

    my $errors = 0;
    my $clientname = hostname();

    my $parceldir = "$isrdir/$parcel";

    # Make sure the current working directory exists
    chdir($isrdir);
    
    # Now remove all traces of the parcel on the client and unlock it
    if (mysystem("rm -rf $parceldir") != 0) {
	err("Unable to remove $parcel.");
	$errors++;
    }

    # If the caller supplied a nonce, then request a soft release
    if ($nonce) {
	if (isr_srun($userid, 
		     "lock", 
		     "-p $userid/$parcel -n $clientname -r $nonce", 
		     "", 0) != 0) {
	    err("Unable to release lock for $parcel. Use 'isr clean' to force the release.");
	    $errors++;
	}
    }

    # No nonce supplied, request a hard release
    else {
	if (isr_srun($userid, "lock", 
		 "-p $userid/$parcel -n $clientname -R", "", 0) != 0) {
	    errexit("Unable to release lock for $parcel.");
	    $errors++;
	}
    }

    return $errors;
}

#
# do_hoard - repeatedly call isr_hoard() protocol method until fully hoarded
#
sub do_hoard ($$$) {
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift;
    
    my $retval;
    
    # Ask the system to hoard all hdk blocks into local store. If the
    # hoard operation returns an error code, then either the network
    # connection is down, the server is down, a chunk in the hoard
    # somehow got corrupted, or a concurrent checkin created a new
    # version on the server while the hoard was underway. In any case,
    # we will restart the hoard operation until it succeeds.
    while (1) {
	$retval = isr_hoard($userid, $parcel, $isrdir);
	if ($retval == $Isr::ESUCCESS) {
	    last; 
	} elsif ($retval == $Isr::EINTR) {
	    errexit("Interrupted");
	}
	print "Sleeping $syscfg{hoard_sleep} secs before restarting hoard...\n"
	    if $verbose;
	sleep($syscfg{hoard_sleep});
    }
}

#
# get_parcelcfg - Retrieve parcel configuration file from the server
#
sub get_parcelcfg ($$$) {
    my $userid = shift;
    my $parcel = shift;
    my $outfile = shift; # Put the retrieved file here

    if (mysystem("ssh -l $userid $server $Isr::ISRSERVERBIN/isr_srv_getconfig.pl -p $parcel > $outfile")) {
	unlink($outfile);
	system_errexit("Parcel $userid/$parcel does not exist on the server ($server).");
    }
}

#
# get_motd - Read message-of-the-day from the server and print it out
#
sub get_motd ($$) {
    my $userid = shift;
    my $parcel = shift;

    mysystem("ssh -l $userid $server $Isr::ISRSERVERBIN/isr_srv_motd.pl -p $parcel -u $userid") == 0
	or system_err("Couldn't read message of the day from the server ($server).");
}

#
# parse_cfgfile - Read a file consisting of key=value pairs (and possibly
#                 comments) and add them to the hash whose ref is provided by
#                 the caller, overriding existing values with the same keys.
#                 The hash is also tied to IsrConfigTie if not already tied.
#                 Returns 0 on error, 1 otherwise.
#
sub parse_cfgfile ($$) {
    my $infile = shift;
    my $hashref = shift;

    my $line;
    my $key;
    my $value;

    # Cause accesses to nonexistent keys to call errexit()
    tie(%$hashref, "IsrConfigTie")
        if (!tied(%$hashref));
    
    # Load the key/value pairs into the hash
    unless (open(INFILE, $infile)) {
	# If the hash already has keys in it, then we're only trying to
	# override existing defaults, so we don't warn if the cfgfile doesn't
	# exist
	unix_err("Config file $infile not found")
	    if (!scalar %$hashref);
	return 0;
    }
    while ($line = <INFILE>) {
	chomp($line);

	# Skip comment lines
	if ($line =~ /^\s*\#/) {
	    next;
	}

	# Otherwise parse out key and value
	($key, $value) = split(/\s*=\s*/, $line);
	if (defined $value) {
	    $hashref->{$key} = $value;
	}
    }
    unless (close(INFILE)) {
	unix_err("Unable to close $infile");
	return 0;
    }

    # Return success
    return 1;
}

#
# parse_parcelcfg - Read a local parcel.cfg file and return a hash containing 
#                   its key/value pairs. Delete the file if there are any
#                   problems.
#
sub parse_parcelcfg ($$$) {
    my $infile = shift;
    my $userid = shift;
    my $parcel = shift;

    my %cfg;

    # Load the key/value pairs into the hash
    if (!parse_cfgfile($infile, \%cfg)) {
	unlink($infile);
	errexit("Couldn't parse parcel.cfg for $userid/$parcel");
    }
    
    # Check parcel format version
    unless (exists $cfg{VERSION} and $cfg{VERSION} == 3) {
	unlink($infile);
	errexit("Unknown or missing VERSION in parcel.cfg for parcel $userid/$parcel.");
    }

    # Every parcel has a PROTOCOL entry
    unless (exists $cfg{PROTOCOL}) {
	unlink($infile);
	errexit("Missing PROTOCOL entry in parcel.cfg for parcel $userid/$parcel.");
    }

    # Every parcel has a MAXKB entry
    unless (exists $cfg{MAXKB}) {
	unlink($infile);
	errexit("Missing MAXKB entry in parcel.cfg for parcel $userid/$parcel.");
    }

    unless (exists $cfg{RPATH}) {
	unlink($infile);
	errexit("Missing RPATH entry in parcel.cfg for parcel $userid/$parcel.");
    }
    
    unless (exists $cfg{WPATH}) {
	unlink($infile);
	errexit("Missing WPATH entry in parcel.cfg for parcel $userid/$parcel.");
    }
    
    unless (exists $cfg{KEYROOT}) {
	unlink($infile);
	errexit("Missing KEYROOT entry in parcel.cfg for parcel $userid/$parcel.");
    }
    
    unless (exists $cfg{SERVER}) {
	unlink($infile);
	errexit("Missing SERVER entry in parcel.cfg for parcel $userid/$parcel.");
    }
    
    # Every read and write path gets appended with the userid and parcel
    $cfg{RPATH} .= "/$userid/$parcel";
    $cfg{WPATH} .= "/$userid/$parcel";

    # Return the hash of key/value pairs to the caller
    return %cfg;
}

#
# build_cache - Create a local Parcelkeeper cache if one doesn't exist already
#
sub build_cache ($$) {
    my $cachedir = shift;
    my $lastdir = shift;

    my $name;

    if (!-e $cachedir) {
	mktree($cachedir)
    	    or errexit("Unable to make $cachedir");
    }

    # Copy the virtualization files from lastdir to cachedir
    if (!-e "$cachedir/cfg") {
	print("Copying virtual machine memory image...\n")
	    if $verbose;
	
	mkdir("$cachedir/cfg")
	    or unix_errexit("Unable to make $cachedir/cfg");
	opendir(DIR, "$lastdir/cfg")
	    or unix_errexit("Unable to read memory image directory $lastdir/cfg");
	foreach $name (readdir(DIR)) {
	    next if ($name eq "." || $name eq "..");
	    copy("$lastdir/cfg/$name", "$cachedir/cfg/$name")
		or unix_errexit("Unable to copy $name from $lastdir/cfg to $cachedir/cfg.");
	}
	closedir(DIR);
    }

    # Copy the keyring files
    if (!-e "$cachedir/keyring") {
	copy("$lastdir/keyring", "$cachedir/keyring")
	    or unix_errexit("Unable to copy $lastdir/keyring");
    }
}

#
# hdksize - Returns the number of chunks present in the local cache
#
sub hdksize ($$$) {
    my $userid = shift;
    my $parcel = shift;
    my $isrdir = shift;

    my $numchunks;

    my $parceldir = "$isrdir/$parcel";
    my $cachedir = "$parceldir/cache";
    my $imageindex = "$cachedir/disk.idx";

    # cache is trivially empty
    return 0
        if ! -e $imageindex;

    # Determine how many chunks are in the local cache
    # XXX
    open(IN, "-|", "$Isr::LIBDIR/query", $imageindex, "SELECT count(*) from chunks")
        or unix_errexit("Unable to read $imageindex");
    $numchunks = <IN>;
    close IN && $? == 0
        or errexit("Unable to query $imageindex");
    
    return int($numchunks);
}

#
# connected - Returns true if the client has a network connection.
#             We have to fork a child and timeout on the wait() 
#             because the bind client coopts SIGALRM signals. 
#
sub connected () {
    my $pid;
    my $childpid;
    my $eval_result;

    $pid = fork();

    # The child tries to establish a connection with root serve
    if ($pid == 0) {
	$no_shutdown = 1;
	my $socket = IO::Socket::INET->new(PeerAddr => $server,
					   PeerPort => "22",
					   Proto    => "tcp",
					   Type     => SOCK_STREAM);
	exit;
    }

    # The parent waits a few seconds for the child to complete, then times out
    $SIG{'ALRM'} = sub {die "timeout"};
    alarm($syscfg{connect_timeout});
    eval {
	waitpid($pid, 0);
    };

    # Determine if the child established a connection in the allotted time.
    alarm(0);
    $eval_result = $@;
    if ($eval_result =~ /timeout/) {
	kill(9, $pid);
	return 0;
    }
    else {
	return 1;
    }
}

#
# check_nexus_version - print a warning if the Nexus release number is older
#                       than our own
#
sub check_nexus_version () {
    my $nexus_version;
    my $nexus_major;
    my $nexus_minor;
    my $nexus_patch;
    my $isr_version = "!!VERSION!!";
    my $isr_major;
    my $isr_minor;
    my $isr_patch;
    my $warn = 0;
    
    if (!-e "/sys/class/openisr/release") {
	print YELLOW, "The OpenISR kernel module is out of date.  Please run 'openisr-config' as root.\n", RESET;
	message("INFO", "Nexus is out of date (<=0.8.3 vs. $isr_version)");
	return;
    }
    open(NEX, "/sys/class/openisr/release")
    	or errexit("Couldn't read Nexus release attribute");
    $nexus_version = <NEX>;
    close(NEX);
    chomp $nexus_version;
    ($nexus_major, $nexus_minor, $nexus_patch) = split(/\./, $nexus_version);
    ($isr_major, $isr_minor, $isr_patch) = split(/\./, $isr_version);
    if ($isr_major >= $nexus_major) {
	if ($isr_major > $nexus_major) {
	    $warn = 1;
	} elsif ($isr_minor >= $nexus_minor) {
	    $warn = 1
	        if ($isr_minor > $nexus_minor or $isr_patch > $nexus_patch);
	}
    }
    if ($warn) {
	print YELLOW, "The OpenISR kernel module is out of date.  Please run 'openisr-config' as root.\n", RESET;
	message("INFO", "Nexus is out of date ($nexus_version vs. $isr_version)");
    }
}

#
# get_dirnum - converts a keyring offset to a directory number
#
sub get_dirnum ($$) {
    my $offset = shift;
    my $chunksperdir = shift;

    return int($offset / $chunksperdir);
}

#
# get_chunknum - converts a keyring offset to a chunk number
#
sub get_chunknum ($$) {
    my $offset = shift;
    my $chunksperdir = shift;

    return $offset % $chunksperdir;
}

#
# get_parcelkeeper_pid - Returns the PID of the Parcelkeeper background
#                        process associated with this parcel, or zero if none
#                        are running.
#
sub get_parcelkeeper_pid () {
    my $pidfile = "$isrdir/$parcel/cache/parcelkeeper.pid";
    my $pid;
    
    -e $pidfile or return 0;
    open(PIDFILE, $pidfile) or return 0;
    defined($pid = <PIDFILE>) or return 0;
    close(PIDFILE);
    chomp($pid);
    # Make sure the process is still alive
    kill(0, $pid) or return 0;
    return $pid;
}

#
# block_sigint - Block receipt of SIGINT (ctrl-c) and return sigmask
# 
sub block_sigint () {
    my $sigset = POSIX::SigSet->new(SIGINT);

    sigprocmask(SIG_BLOCK, $sigset)
	or errexit("Could not block SIGINT");
    return $sigset;
}

#
# unblock_sigint - Unblock receipt of SIGINT
#
sub unblock_sigint ($) {
    my $sigset = shift;

    sigprocmask(SIG_UNBLOCK, $sigset) 
	or errexit("Could not unblock SIGINT");
}

#
# block_sigtstp - Block receipt of SIGTSTP (ctrl-z) and return sigmask
# 
sub block_sigtstp () {
    my $sigset = POSIX::SigSet->new(SIGTSTP);

    sigprocmask(SIG_BLOCK, $sigset)
	or errexit("Could not block SIGTSTP");
    return $sigset;
}

#
# mysystem - Version of Unix 'system' function that can be 
#            interrupted with ctrl-c
#
sub mysystem ($) {
    my $cmd = shift;

    if (!defined($pid = fork())) {
	unix_errexit("Unable to fork in mysystem");
    } 

    # Child
    elsif ($pid == 0) {
	$no_shutdown = 1;
	exec($cmd)
	    or unix_errexit("Unable to exec $cmd in mysystem");
    } 

    # Parent
    waitpid($pid, 0);
    return $?; # Return exit status of the child
}

#
# sys_sync - Call sync(2)
#
sub sys_sync () {
    if ($Config{'myarchname'} =~ /i.86-linux/ and SYS_sync() == 162) {
	# On Ubuntu Feisty on 32-bit x86, SYS_sync() reports the syscall number
	# for sync() on the AMD64 architecture, which is not the same number.
	# In this case syscall(&SYS_sync) is actually a call to nanosleep()
	# with garbage arguments, which hangs forever.  So we hardcode the
	# syscall number for this case.
	syscall(36);
    } else {
	syscall(&SYS_sync);
    }
}

#
# mktree - Make the directory named by the argument, and all of its parents.
#          Returns true if successful or the directory already exists, false
#          on error.
#
sub mktree ($) {
    my $tree = shift;
    
    # mkpath() throws a fatal error on failure, so we have to trap it
    eval {mkpath($tree)};
    return 0 if $@;
    return 1;
}

######
# Error reporting routines
#

#
# err - Print an error message without exiting
#
sub err ($) {
    my $msg = shift;

    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print "[$progname] Warning: $msg\n";
    message("ERROR", "[$progname] Warning: $msg");
}

#
# unix_err - Print an error message (with Unix strerr)
#
sub unix_err ($) {
    my $msg = shift;

    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print "[$progname] Warning: $msg ($!)\n";
    message("ERROR", "[$progname] Warning: $msg");
}

#
# errexit - Print an error message and exit
#
sub errexit ($) {
    my $msg = shift;

    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print RED, "[$progname] Error: $msg\n", RESET;
    message("ERROR", "[$progname] Error: $msg");
    exit $Isr::EINVAL;
}

#
# unix_errexit - Print an error message (with Unix strerr) and exit
#
sub unix_errexit ($) {
    my $msg = shift;

    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print RED, "[$progname] Error: $msg ($!)\n", RESET;
    message("ERROR", "[$progname] Error: $msg ($!)");
    exit $Isr::EINVAL;
}

#
# system_err - Print an error after the system() function fails
#
sub system_err ($) {
    my $msg = shift;

    my $exit_value = $? >> 8;
    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    # $? is the wait() style return value. $! is strerr[errno]
    # $exit_value  = $? >> 8;
    # $signal_num  = $? & 127;
    # $dumped_core = $? & 128;
    print RED, "[$progname] Error: $msg\n", RESET;
    message("ERROR", "[$progname] Error: $msg");
    
    # Pass the exit value back to the caller
    return $exit_value; 
}

#
# system_errexit - Print an error and exit after the system() function fails
#
sub system_errexit ($) {
    my $msg = shift;
    
    exit system_err($msg);
}

#
# message - Emits a message to the ISR client side session log
#
sub message($$) {
    my $event = shift;
    my $msg = shift;

    my $date = localtime();
    my $string;
    my $isrdir;

    return
        if !$log_enabled;
    $string = message_string();
    $isrdir = "$ENV{HOME}/.isr/$userid";
    open(LOG, ">>$isrdir/$parcel.log")
	or return;
    print LOG "$date|$event|$string|$msg\n";
    close(LOG);
}

#
# message_string - returns the inner fields of a log message string
#
sub message_string {
    my $hostname = hostname();

    return "$$|$hostname|$sessionid";
}

#
# query - Ask the user a question and return the reply
#
sub query {
    my $question = shift;

    my $reply;

    print RED, "$question (y/n): ", RESET;
    $reply = <STDIN>;
    chomp($reply);

    # Keep asking until the user replies either y or n
    while ($reply ne "y" and $reply ne "n") {
	print RED, "$question (y/n): ", RESET;
	$reply = <STDIN>;
	chomp($reply);
    }
    return $reply;
}

#
# mypause - Pause and then continue on 'y' and exit on 'n'
#
sub mypause($) {
    my $msg = shift;

    my $reply;

    if ($main::verbose > 1) {
	$reply = query($msg);
	if ($reply eq "n") {
	    exit;
	}
    }
}

#
# usage - Print help message and terminate.  usage("") is special: it prints
#         the long-form help.
#
sub usage ($) {
    my $msg = shift;
    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    if ($msg) {
        print RED, "Error: $msg\n", RESET;
    }

    print RED, "Usage: $progname command [parcel] [options...]\n", RESET;
    print BLUE, "Commands: auth, checkin (ci), checkout (co), checkp, clean, deauth, discard,\n", RESET;
    print BLUE, "          disconnect, help, hoard, ls, passwd, reset, resume, stat, sync,\n", RESET;
    print BLUE, "          version\n", RESET;
    print BLUE, "Parcel is required for most commands\n", RESET;
    if (!$msg) {
	print "Basic commands:\n";
	print "  auth       Authenticate to the ISR server (once per X session only).\n";
	print "  checkin    Sync parcel to server and release lock (-b optional).\n";
	print "  checkout   Fetch parcel from server and acquire its lock (-r optional).\n";
	print "  checkp     Check parcel on server for consistency (-r and -c optional).\n";
	print "  clean      Remove parcel from client and release its lock (-a optional).\n";
	print "  deauth     Remove authentication credentials from your client.\n";
	print "  discard    Discard all local changes to parcel since last checkout or sync.\n";
	print "  disconnect Prepare the client to run a parcel disconnected (-x optional).\n";
	print "  help       Print help message.\n";
	print "  hoard      Fetch entire virtual disk so you can run disconnected.\n";
	print "  ls         List info about your parcels (parcel, -l and -L optional).\n";
	print "  passwd     Change your ISR password on the server.\n";
 	print "  reset      Reset ISR runtime.\n";
 	print "  resume     Checkout (if necessary) and run a parcel (-r and -d optional).\n";
	print "  stat       Display information about local ISR state (-c optional).\n";
	print "  sync       Make new parcel version on server w/o releasing lock (-b optional).\n";
	print "  version    Print ISR version.\n";
    }
    print "Options:\n";
    print "  -a,--allstate      Remove all hoarded state from client [clean].\n";
    print "  -b,--bwlimit       Bandwidth limit (KBytes/s) [ci, sync].\n";
    print "  -c,--checkstate    Do additional consistency check [checkp, stat].\n";
    print "  -d,--disconnected  Run disconnected (after hoarding) [resume].\n";
    print "  -l,--long          Long listing with default number of versions [ls].\n";
    print "  -L,--longvers      Long listing with specific number of versions [ls].\n";
    print "  -q,--quiet         Run silently (except if things go wrong).\n";    
    print "  -r,--rollback      Rollback to or check version [co, checkp].\n";
    print "  -s,--server        Server domain name (optional).\n";
    print "  -u,--user          Your ISR user name (defaults to your login name).\n";    
    print "  -v,--verbose       Increment verbosity level.\n";
    print "  -x,--nocheckstate  Skip consistency check [ci, sync, disconnect].\n";
    print "  -X,--noauto        Don't automatically start/stop VMware [resume].\n";
    print "\n";
    
    exit 0;
}
