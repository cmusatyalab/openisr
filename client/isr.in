#!/usr/bin/perl
###################################################################
# isr - The ISR client program
###################################################################

#
# isr - Client user interface for the Internet Suspend/Resume (R) system
#
# Copyright (C) 2004-2007 Carnegie Mellon University
#
# This software is distributed under the terms of the Eclipse Public
# License, Version 1.0 which can be found in the file named LICENSE.Eclipse.
# ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES
# RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT
#

#####################
# Section 0: Prologue
#####################

use Sys::Hostname;
use Getopt::Long;
use IO::Socket;
use File::Path;
use File::Copy;
use File::stat;
use Term::ANSIColor qw(:constants);
use POSIX ":sys_wait_h";
use POSIX ":signal_h";
use Fcntl qw(:DEFAULT :seek);
use Errno qw(:POSIX);
use Config;
require "syscall.ph";
use lib "!!SHAREDIR!!";
use Isr;
use IsrConfigTie;
use IsrRevision;
use strict;
use warnings;

$| = 1; # Autoflush output on every print statement


# Function prototypes
sub checkout ();
sub run ();
sub checkin ();
sub sync ($);
sub discard ();
sub disconnect ();
sub listparcels ();
sub authenticate ();
sub deauthenticate ();
sub passwd ();
sub release ();
sub clean ($);
sub resetclient ();
sub cleanclient ();
sub hoard ();
sub do_hoard ();
sub checkparcel ();
sub statparcel ();
sub get_parcelcfg ($);
sub get_motd ();
sub parse_cfgfile ($$);
sub parse_parcelcfg ($);
sub build_cache ();
sub hdksize ();
sub connected ();
sub check_nexus_version ();
sub get_parcelkeeper_pid ();
sub block_sigint ();
sub unblock_sigint ($);
sub block_sigtstp ();
sub mysystem ($);
sub sys_sync ();
sub mktree ($);
sub err ($);
sub unix_err ($);
sub errexit ($);
sub unix_errexit ($);
sub system_errexit ($);
sub system_err ($);
sub message ($$);
sub usage ($);
sub need_parcel ();
sub need_not_parcel ();
sub need_checked_out ();
sub need_network ();
sub acquire_lock ($$);
sub release_locks ();
sub exit_handler ($);

# Old HTTPSSH prototypes
sub isr_sget ($$$$);
sub isr_srun ($$$$$);
sub isr_connected_parcel ();
sub isr_connected_http ();
sub isr_run_parcelkeeper ($$);
sub isr_hoard ();
sub isr_stathoard ();
sub isr_sync ($);
sub isr_checkhoard ();
sub isr_priv_upload ();
sub copy_dirtychunks ();
sub isr_priv_commit ($);
sub isr_priv_clientcommit($);
sub isr_priv_cleanhoard ();

#########################
# Section 1. Main routine
#########################

# Local variables
my $isrdir;
my $isrhome;
my $result;
my $progname; 

# Command line arguments that are private to this module
my $disconnected;    # Run disconnected
my $longflag;        # Print default number of versions for ls long format
my $longvers;        # Print specific number of versions for ls long format
my $version;         # Rollback version
my $checkstate = 0;  # Optionally check content consistency in some cmds
my $noautoflag;      # Don't automatically start/stop VMware at launch time
my $allflag;         # "clean" should delete all state, including hoard cache

# Write once globals that are visible in this module only. These globals are
# needed to cleanly handle logging.
my $log_enabled = 0;# Is logging enabled?
my $pid;            # Pid of child created in mysystem
my $sessionid = 0;  # Unique session id (nonce from lock operation)
my $userid;         # ISR userid
my $parcel;         # parcel name
my $command;        # isr subcommand

# State globals, visible in this module only, which track which cleanup actions
# will be necessary when we exit.
my $no_shutdown = 0;# Set by forked children so the child won't run END
my $kill_pk = 0;    # Set by run command, tells END handler to kill Parcelkeeper
my @locks;          # Names and FDs of open lock files

# Read-only command line arguments that are visible to other modules.
my $verbose = 1;    # Verbosity level; by default, we print a few messages
my $nocheckstate;   # Skip state  consistency check in ci, sync, disconnect
my $bwlimit;        # Bandwidth limit (KBytes/sec) in ci and sync
my $server;         # Server domain name
my $parceldir;
my $cachedir;
my $lastdir;
my $tmpdir;
my $hoarddir;
my $cdcache_file;

#
# Read/write global variable: At any point in time, this hash contains
# the key/value pairs from the parcel.cfg for the current parcel. For
# each command except listparcels, %cfg is initialized exactly once, 
# and only by calls to parse_parcelcfg.  This variable is tied such that
# accesses to nonexistent keys will result in a call to errexit().
# XXX false!
#
my %cfg = ();

#
# Write-once global variable containing the key/value pairs from the
# global and per-user configuration files.  This variable is tied such that
# accesses to nonexistent keys will result in a call to errexit().
#
my %syscfg = ();

#####
# Some initialization steps
#

#
# Define what we do on shutdown (placed here for clarity)
#
sub exit_handler ($) {
    my $status = shift;
    
    my $pid;
    
    return if $no_shutdown;
    
    if ($kill_pk) {
	$pid = get_parcelkeeper_pid();
	if ($pid != 0) {
	    kill("TERM", $pid);
	    print("Sent shutdown signal to Parcelkeeper.\n")
		if $verbose;
	}
    }
    sys_sync();
    sys_sync();
    
    # Remove temporary files
    system("rm -f /tmp/*.$$");
    system("rm -rf $isrdir/tmplast*")
	if $isrdir;
    
    message("EXIT", $status);
    release_locks();
}

#
# Run the exit handler during normal termination
#
END {
    my $status=$?;
    exit_handler($status);
    $? = $status;
}

#
# Install a signal handler that catches ctrl-c
#
sub sigint_handler () {
    message("INFO", "Caught SIGINT");
    # Call the exit handler, then unregister the signal handler and send the
    # signal again (whereupon we will die).  This ensures that our exit status
    # properly reports that we were killed by a signal.
    exit_handler(-1);
    $SIG{"INT"} = 'DEFAULT';
    kill("INT", $$);
};

$SIG{"INT"} = \&sigint_handler;

#
# Parse config files
#

# This file must exist, since it provides our defaults
parse_cfgfile("$Isr::SHAREDIR/config", \%syscfg)
    or errexit("Can't read defaults file $Isr::SHAREDIR/config");
# These may not exist, but can override the earlier ones
parse_cfgfile("$Isr::SYSCONFDIR/openisr.conf", \%syscfg);
parse_cfgfile("$ENV{HOME}/.openisrrc", \%syscfg);

#####
# Various defaults
#

#
# Check if the user is running as root
#
if ((getpwuid($<))[0] eq "root") {  # Reminder: '$<' is the UID 
    errexit("Root is not allowed to run the isr client program.");
}

# The default ISR userid is defined by $syscfg{userid}.
# If this is empty, then the default is the Unix login name.
# Override using the -u flag.
$userid = $syscfg{userid}
    if exists($syscfg{userid});
$userid = $ENV{USER}
    if (!$userid);

# Set the default server; may be overridden from command line
$server = $syscfg{server};

# Strip off pathname from the program name
($progname = $0) =~ s#.*/##s; # Strip off path from program name

#
# Handle the case where the user calls the program with no arguments
#
if (@ARGV == 0) {
    print("$progname: Try '$progname help' for more information.\n");
    exit 0;
}

#
# Parse the command line
#
Getopt::Long::Configure("no_ignore_case", "bundling_override",
			"no_getopt_compat");
$result = GetOptions(
		     "a|allstate"     => \$allflag,
		     "b|bwlimit=i"    => \$bwlimit,
		     "c|checkstate+"  => \$checkstate,
		     "x|nocheckstate" => \$nocheckstate,
		     "d|disconnected" => \$disconnected,
		     "l|long"         => \$longflag,
		     "L|longvers=i"   => \$longvers,
		     "q|quiet"        => sub { $verbose = 0 },
		     "r|rollback=i"   => \$version,
		     "s|server=s"     => \$server,
		     "u|user=s"       => \$userid,
		     "v|verbose+"     => \$verbose,
		     "X|noauto"       => \$noautoflag
		     );

if ($result == 0) {
    usage("Invalid option(s) specified");
}

#
# Extract the command name
#
if (@ARGV == 0) {
    usage("Missing command");
}
if (@ARGV > 2) {
    usage("Extraneous parameters on command line");
}
$command = $ARGV[0];
$parcel = $ARGV[1];

#
# Set the the directory where ISR parcels will be stored and if
# it doesn't yet exist, create an empty one.
#
$isrhome = "$ENV{HOME}/.isr";
$isrdir = "$isrhome/$userid";

if (!-e $isrhome) {
    mkdir($isrhome)
	or unix_errexit("Unable to make $isrhome");
}
if (!-e $isrdir) {
    mkdir($isrdir)
	or unix_errexit("Unable to make $isrdir");
}
if (!-d $isrdir) {
    errexit("$isrdir is not a directory");
}

#
# Set other directory paths that we'll need.
#
if ($parcel) {
    $parceldir = "$isrdir/$parcel";
    $cachedir = "$parceldir/cache";
    $lastdir = "$parceldir/last";
    $tmpdir = "$parceldir/tmp";
    # Existence of this file is a flag indicating that the temporary
    # dirty cache is consistent with the local cache.
    $cdcache_file = "$parceldir/consistent-dirtycache-flag";
}
$hoarddir = "$isrdir/hoard";

#
#
# Assign aliases
#
if ($command eq "ci") {
    $command = "checkin"
}
if ($command eq "co") {
    $command = "checkout"
}
if ($command eq "checkp") {
    $command = "checkparcel"
}


#####
# Process the command
#

#
# Set the session ID to the nonce value if the parcel is 
# checked out, zero otherwise.
#
$sessionid = 0;
if ($parcel && -e "$isrdir/$parcel/nonce" && open(NONCE, "$isrdir/$parcel/nonce")) {
    $sessionid = <NONCE>;
    close(NONCE);
    chomp($sessionid);
}

#
# Now process the ISR command.
#

# Basic commands
if ($command eq "checkout") {
    need_parcel();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    checkout();
} 
elsif ($command eq "resume") {
    need_parcel();
    # Resume will need a network connection if the requested parcel is not
    # currently checked out, or if the parcel is checked out and we're not
    # planning on running disconnected.
    need_network()
	if ((!-e "$isrdir/$parcel") or
	    (-e "$isrdir/$parcel" and !$disconnected));
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    checkout();
    run();
} 
elsif ($command eq "checkin") {
    need_parcel();
    need_checked_out();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    checkin();
} 
elsif ($command eq "sync") {
    need_parcel();
    need_checked_out();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    sync(0);
} 
elsif ($command eq "discard") {
    need_parcel();
    need_checked_out();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    discard();
}
elsif ($command eq "hoard") {
    need_parcel();
    acquire_lock("$isrdir/$parcel-hoard.lock", "Hoard cache");
    hoard();
}
elsif ($command eq "stat") {
    need_parcel();
    need_checked_out();
    acquire_lock("$isrdir/$parcel.lock", "Parcel")
	if $checkstate;
    statparcel();
}
elsif ($command eq "disconnect") {
    need_parcel();
    need_checked_out();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel")
	if (!$nocheckstate);
    acquire_lock("$isrdir/$parcel-hoard.lock", "Hoard cache");
    disconnect();
}
elsif ($command eq "checkparcel") {
    need_parcel();
    need_network();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    checkparcel();
}
elsif ($command eq "ls") {
    need_network();
    listparcels();
}
elsif ($command eq "auth") {
    need_not_parcel();
    need_network();
    authenticate();
}
elsif ($command eq "deauth") {
    need_not_parcel();
    deauthenticate();
}
elsif ($command eq "passwd") {
    need_not_parcel();
    need_network();
    passwd();
}
elsif ($command eq "reset") {
    need_not_parcel();
    resetclient();
}
elsif ($command eq "clean") {
    need_parcel();
    acquire_lock("$isrdir/$parcel.lock", "Parcel");
    acquire_lock("$isrdir/$parcel-hoard.lock", "Hoard cache")
	if $allflag;
    cleanclient();
}
elsif ($command eq "help") {
    need_not_parcel();
    usage("");
}
elsif ($command eq "version") {
    need_not_parcel();
    # These are the copyrights for the entire OpenISR client codebase, not
    # just the user interface.
    print <<END;
OpenISR !!VERSION!!, client revision $Isr::RCS_REVISION

Copyright (C) 2000-2007 Carnegie Mellon University and others
The OpenISR system comes with ABSOLUTELY NO WARRANTY.  Different parts of
this software are distributed under different licenses, including the
Eclipse Public License, version 1.0; the GNU General Public License, version 2;
and the GNU Lesser General Public License, version 2.1.  See the README file
included with this software for details on which license applies to each
component of the OpenISR system.
END
    exit 0;
}
# Everything else
else {
    usage("$command is an invalid command.");
}    

#
# Clean up and exit
#
message("END", $command);
exit 0;


##########################################
# Section 2. Definition of client commands
##########################################

#
# checkout - Lock a parcel and copy it from the server to the client
#
sub checkout () {
    my $diskinfo = `df -P -k $isrhome | tail -n 1`;
    my ($diskpartition, $diskblocks, $diskused, $diskspace, $diskpercent, $diskroot) = split(" ", $diskinfo);

    my $retval;
    my $target;
    my $cfgsize;
    my $tmpfile;
    my $cfg_sha1value;
    my $key_sha1value;
    my $cfg_file;
    my $key_file;
    my $clientname = hostname();
    my $sigset;
    my %map;

    # If the parcel is already checked out on this machine, return immediately
    if (-e $parceldir) {
	print(GREEN, "Success: Parcel $userid/$parcel already checked out on this host. Ready to run.\n", RESET)
	    if $verbose;
	return;
    }
    
    # Fetch and print message-of-the-day from the server
    print "Connecting to server.\n"
    	if $verbose;
    get_motd();

    # Fetch and parse the config file from the server
    print "Fetching configuration data for $userid/$parcel from server.\n"
	if $verbose;
    get_parcelcfg("$isrdir/$parcel-parcel.cfg");
    %cfg = parse_parcelcfg("$isrdir/$parcel-parcel.cfg");

    # Before going any further, make sure we have a protocol level
    # connection to the server and a consistent parcel.
    if (!isr_connected_http()) {
	errexit("The server appears to be down.");
    }
    if (!isr_connected_parcel()) {
	errexit("The remote parcel is not available.");
    }

    # Confirm that there is enough disk space.
    if ($diskspace < $cfg{MAXKB}) {
	errexit("Not enough disk space [$diskspace/$cfg{MAXKB} KB available]");
    }

    # From this point on, the operation should not be interrupted by the user
    $sigset = block_sigint();

    # Grab the lock from the server
    print("Acquiring lock from server.\n")
	if $verbose;

    if (isr_srun($userid, "lock", 
		 "-p $userid/$parcel -n $clientname -a", 
		 "$isrdir/$parcel-nonce", 0) != 0) {
	unlink("$isrdir/$parcel-nonce");
	errexit("Unable to acquire lock for $parcel.");
    }

    # Use the nonce from the lock operation as the unique session id
    if (-e "$isrdir/$parcel-nonce" && open(NONCE, "$isrdir/$parcel-nonce")) {
	$sessionid = <NONCE>;
	close(NONCE);
	chomp($sessionid);
    }

    # If requested, roll back to a previous version on the server
    if ($version) {
	if ($version < 1) {
	    clean(0);
	    errexit("Version numbers must be greater than zero.");
	}
	print("Rolling back to version $version.\n")
	    if $verbose;
	if (isr_srun($userid, "rollback", 
		     "-u $userid -p $parcel -v $version", "", 0) != 0) {
	    clean(0);
	    errexit("Unable to roll back to version $version");
	}
    }

    # Set up the client's parcel directory. If anything goes wrong erase 
    # all traces of the parcel on the client and release its lock.
    if (!mktree($parceldir)) {
	clean(0);
	errexit("Unable to create parcel dir $parceldir.");
    }
    if (!mktree($lastdir)) {
	clean(0);
	errexit("Unable to create last dir $lastdir.");
    }

    if (!rename("$isrdir/$parcel-nonce", "$parceldir/nonce")) {
	clean(0);
	errexit("Unable to move $isrdir/$parcel-nonce to $parceldir");
    }
    if (!rename("$isrdir/$parcel-parcel.cfg", "$parceldir/parcel.cfg") != 0) {
	clean(0);
	errexit("Unable to move $isrdir/$parcel-parcel.cfg to $parceldir");
    }

    #
    # Save the keyroot in the parcel directory (otherwise we would
    # need to include the actual keyroot on the command line)
    #
    open(KEYROOT, ">$lastdir/keyroot") 
	or errexit("Unable to open $lastdir/keyroot for writing");
    print KEYROOT "$cfg{KEYROOT}";
    close(KEYROOT);

    #
    # Fetch the parcel's virtualization files from the server
    #
    $tmpfile = "/tmp/stat.$$";
    if (isr_srun($userid, "stat", 
		 "-f $userid/$parcel/last/cfg.tgz.enc",
		 $tmpfile ,0) != 0) {
	unlink($tmpfile);
	clean(0);
	errexit("Unable to stat cfg.tgz.enc file on server");
    }
    parse_cfgfile($tmpfile, \%map);
    unlink($tmpfile);
    $cfgsize = $map{SIZE};
    $cfg_sha1value = $map{SHA1};

    $tmpfile = "/tmp/stat2.$$";
    if (isr_srun($userid, "stat", 
		 "-f $userid/$parcel/last/keyring.enc",
		 $tmpfile ,0) != 0) {
	unlink($tmpfile);
	clean(0);
	errexit("Unable to stat keyring.enc file on server");
    }
    %map = ();
    parse_cfgfile($tmpfile, \%map);
    unlink($tmpfile);
    $key_sha1value = $map{SHA1};

    #
    # Look aside to see if the memory image and/or keyring is available 
    #
    printf("Fetching virtual machine memory image (%d MB)...\n", int($cfgsize/(1<<20)))
	if $verbose;

    # XXX
#    if (-e "$hoarddir/$cfg_sha1value") {
#	print "Found local match for encrypted memory image.\n"
#	    if $verbose;
#	$cfg_file = "$hoarddir/$cfg_sha1value";
#    }

#    if (-e "$hoarddir/$key_sha1value") {
#	print "Found local match for encrypted keyring.\n"
#	    if $verbose;
#	$key_file = "$hoarddir/$key_sha1value";
#    }    

    #
    # Fetch the memory and meta files to a temp file and then commit.
    # isr_sget() will block SIGINT while curl runs, but will return
    # $Isr::EINTR if curl itself dies on a signal.  In order to let
    # this work, we unblock SIGINT and install a dummy signal handler
    # for the duration of this loop so that curl doesn't end up
    # blocking or ignoring SIGINT as well.  This means we lose SIGINTs
    # which are pending from before this loop.
    #
    unlink("$lastdir/tmpfile");
    $SIG{'INT'} = sub {};
    unblock_sigint($sigset);
    foreach $target ("keyring.enc", "cfg.tgz.enc") {
	next if ($target eq "keyring.enc" && $key_file);
	next if ($target eq "cfg.tgz.enc" && $cfg_file);
	
	print "Fetching $target...\n"
	    if ($verbose > 1);

	# Show a progress meter only for the big cfg file
	$retval = isr_sget($userid, "last/$target", "$lastdir/tmpfile",
			    ($target eq "cfg.tgz.enc"));
	if ($retval == $Isr::EINTR) {
	    print "\n";
	    # We now have an inconsistent parcel directory.  Blow it away
	    # and release the server lock.
	    clean($sessionid);
	    errexit("Fetch interrupted by signal");
	}
	$retval == $Isr::ESUCCESS
	    or errexit("Unable to fetch $target file");
	rename("$lastdir/tmpfile", "$lastdir/$target")
	    or unix_errexit("Unable to commit $lastdir/$target");
    }
    $sigset = block_sigint();
    $SIG{'INT'} = \&sigint_handler;
    
    #
    # Decrypt and unpack the virtualization and Parcelkeeper files
    #
    print("Decrypting and uncompressing virtual machine memory image...\n")
	if $verbose;
    $key_file = "$lastdir/keyring.enc"
    	if !$key_file;
    $cfg_file = "$lastdir/cfg.tgz.enc"
    	if !$cfg_file;
    if (mysystem("openssl enc -d -aes-128-cbc -in $key_file -out $lastdir/keyring -pass file:$lastdir/keyroot -salt") != 0) {
	errexit("Could not decrypt keyring.enc");
    }
    if (mysystem("pv -peW -s $cfgsize $cfg_file | openssl enc -d -aes-128-cbc -pass file:$lastdir/keyroot -salt | tar xz --directory $lastdir") != 0) {
	errexit("Could not decrypt and unpack cfg.tgz.enc");
    }
    # Keyroot no longer needed, get rid of it
    foreach $target ("keyring.enc", "cfg.tgz.enc", "keyroot") {
	if (-e "$lastdir/$target" && !unlink("$lastdir/$target")) {
	    clean(0);
	    errexit("Unable to remove $target.");
	}
    }

    # Clean up and return
    sys_sync();
    print(GREEN, "Success: Parcel $userid/$parcel now checked out (and lock acquired).\n", RESET)
	if $verbose;
    unblock_sigint($sigset);
    return;
}

#
# run - Execute a parcel on the client
#
sub run () {
    my $target;
    my @files;
    my $dirname;
    my $cfgfile;  # VMware configuration file
    my $numfiles;
    my $numchunks;
    my $i;
    my $iters;
    my $sigset;
    my $vmware_opts;
    my $pk_pid;
    my $devnode;
    
    my $pkcmd = "$Isr::LIBDIR/parcelkeeper";

    # Block receipt of the SIGTSTP (ctrl-z)
    block_sigtstp();

    # Reset the consistent dirty cache flag, since any temporary dirty
    # cache directory is about to become inconsistent with the local cache.
    unlink($cdcache_file);

    # Parse the parcel config file that we got from the server during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg");

    # If the user wants to run connected, then before going any further, 
    # make sure we have a protocol level connection to the server
    # and a consistent parcel.
    if (!$disconnected and !isr_connected_http()) {
	errexit("The server appears to be down.");
    }
    if (!$disconnected and !isr_connected_parcel()) {
	errexit("The remote parcel is not available.");
    }

    # Make sure that Parcelkeeper is where we expect it to be, that Nexus is
    # loaded, and that the control device exists.  Also, warn if the Nexus
    # release is older than our own release.
    if (!-e $pkcmd or !-x $pkcmd ) {
	errexit("Could not find an executable Parcelkeeper binary.");
    }
    if (!-d "/sys/class/openisr") {
        errexit("The OpenISR kernel module does not appear to be loaded.");
    }
    if (!-e "/dev/openisrctl") {
        errexit("Nexus control device does not exist");
    }
    check_nexus_version();

    # If the user wants to run disconnected, they better have all of their
    # disk blocks hoarded in the local or hoard cache
    if ($disconnected) {
	$numchunks = hdksize(); 

	# If the local cache is not fully populated, then make sure
	# the hoard cache is fully populated
	if ($numchunks != $cfg{NUMCHUNKS}) {
	    if (isr_stathoard() != $cfg{NUMCHUNKS}) {
		errexit("Running disconnected without a fully hoarded parcel.\nPlease run \"isr disconnect $parcel\" first.");
	    }
	}
	print("Running disconnected...\n")
	    if $verbose;
    }

    # Create a Parcelkeeper cache if one doesn't already exist
    # This operation must not be interrupted by the user
    print("Initializing local cache.\n")
	if $verbose;

    $sigset = block_sigint();
    build_cache();
    unblock_sigint($sigset);

    # Make sure there is exactly one VMware config file
    opendir(DIR, "$cachedir/cfg")
	or unix_errexit("Unable to open $cachedir/cfg");
    @files = grep(/\.vmx$/, readdir(DIR));
    closedir(DIR);
    $numfiles = @files;
    if ($numfiles != 1) {
	errexit("Found $numfiles virtual machine config files, but expected exactly one.");
    }
    $cfgfile = $files[0];
    
    # Launch Parcelkeeper. 
    print("Launching Parcelkeeper...\n")
	if $verbose;
    $kill_pk = 1;  # Tells the SIGINT handler to cleanly terminate PK
    isr_run_parcelkeeper("run", "parcel cache hoard compression log") == 0
	or errexit("Unable to launch Parcelkeeper.");	
    
    # Find out what device node we'll be using
    open(DEVFILE, "$cachedir/parcelkeeper.dev")
    	or unix_errexit("Can't open $cachedir/parcelkeeper.dev");
    chomp($devnode = <DEVFILE>);
    close(DEVFILE);
    message("INFO", "Using device node $devnode");
    
    # Wait for udev to catch up
    $iters = 0;
    while (1) {
	# Get Parcelkeeper pid and make sure it's still alive
	$pk_pid = get_parcelkeeper_pid();
	if ($pk_pid == 0) {
	    errexit("Parcelkeeper died unexpectedly");
	}
	last if -e $devnode;
	# Sleep 100 ms
	select(undef, undef, undef, 0.1);
	# Give up after 15 s
	errexit("Timed out waiting for creation of device node $devnode")
	    if (++$iters == 150);
    };

    # Launch VMware
    print "Launching VMware...\n"
	if $verbose;
    if (!$noautoflag) {
        $vmware_opts = "-X";
    } else {
        $vmware_opts = "";
    }
    mysystem("LD_PRELOAD=libvdisk.so.0 VDISK_DEVICE=$devnode $syscfg{vmcommand} $vmware_opts $cachedir/cfg/$cfgfile") == 0
	or system_errexit("VMware terminated abnormally.");

    # Wait here until the user suspends VMware
    print "Shutting down VMware.\n"
	if $verbose;
    
    # Signal Parcelkeeper to shut down and wait until it is gone
    print "Shutting down Parcelkeeper (pid=$pk_pid)"
	if $verbose;
    kill("TERM", $pk_pid);
    $kill_pk = 0;
    message("INFO", "Sent SIGTERM signal to Parcelkeeper (pid=$pk_pid)");
    $iters = 0;
    while (1) {
	if (++$iters > 60) {
	    print "\n";
	    errexit("Unable to shutdown Parcelkeeper");
	}
	print "."
	    if $verbose;
	last
	    if get_parcelkeeper_pid() == 0;
	sleep(1);
    }
    print "\n"
	if $verbose;
}

#
# checkin - Sync and then release parcel
#
sub checkin () {
    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg");

    # Sync the dirty blocks on the server
    sync(1) == $Isr::ESUCCESS
	or errexit("Sync of parcel $userid/$parcel failed.");

    # Release the lock on the parcel
    release() == $Isr::ESUCCESS
	or errexit("Release of parcel $userid/$parcel failed.");
}

#
# sync - Make local state clean
#
sub sync ($) {
    my $releasing = shift;  # whether we're releasing the lock afterward

    my $relstring = "";
    my $vflag = "-q";
    my $bwflag = "";
    my $i;

    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg");

    # Now call the protocol-specific sync function
    isr_sync($releasing) == $Isr::ESUCCESS
	or errexit("Sync of parcel $userid/$parcel failed.");
    
    # Append the session log to the persistent log in remote storage
    # and if successful delete the session log. 
    message("INFO", "Uploading session log");
    print "Uploading session log...\n"
	if $verbose;

    $vflag = "--progress"
	if ($verbose);
    $bwflag = "--bwlimit=$bwlimit"
	if ($bwlimit);

    # Retry if the put operation fails
    for ($i = 0; $i < $syscfg{retries}; $i++) {
	if (mysystem("rsync -e ssh --partial -z $vflag $bwflag $isrdir/$parcel.log $userid\@$cfg{WPATH}/session.log.new") == 0) {
	    if (isr_srun($userid, "catlog", "-u $userid -p $parcel -f session.log.new", "", 0) == 0) {
		unlink("$isrdir/$parcel.log");
		last;
	    }
	}
	print "[isr] put operation failed. Retrying...\n"
	    if $verbose;
    }
    
    $relstring = " (but not released)"
	if !$releasing;
    print(GREEN, "Success: Sync completed. Parcel checkpointed$relstring.\n", RESET)
	if $verbose;

    return $Isr::ESUCCESS;
}

#
# upload - Upload the contents of the local cache to the server (DEBUG only)
#
sub upload ($$$) {
    my $userid = shift;     # login name
    my $parcel = shift;     # parcel name
    my $isrdir = shift;     # absolute path of local ISR home dir

    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg");

    # Now call the protocol-specific sync function
    isr_priv_upload();
    
    return $Isr::ESUCCESS;
}

#
# discard - Remove the Parcelkeeper cache
#
sub discard () {
    my $reply;

    # Give users a chance to change their minds.
    if ($verbose) {
	$reply = query("This command deletes local session state on this host. Proceed?");
	if ($reply eq "n") {
	    return;
	}
    }

    # This operation should not be interrupted by the user
    block_sigint();

    # Delete the local cache
    if (-e $cachedir) {
	mysystem("rm -rf $cachedir");
    }

    #
    # Reset the consistent dirty cache flag, since any temporary dirty
    # cache directory can no longer be consistent with an empty local cache.
    #
    unlink($cdcache_file);

    print(GREEN, "Success: Local changes to parcel $userid/$parcel discarded.\n", RESET)
	if $verbose;

}

#
# disconnect - Prepare the host to disconnect from a parcel
#
sub disconnect () {
    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg");

    print "Preparing client host to run parcel $userid/$parcel disconnected...\n";
    
    if (!$nocheckstate) {
	print "Hint: Use the -x option to skip the lengthy consistency check.\n";
    }


    # Hoard the parcel if it's not already hoarded
    if (isr_stathoard() < $cfg{NUMCHUNKS}) {
	do_hoard();
    }

    # Optionally check the hoard cache for consistency
    if (!$nocheckstate) {
	isr_checkhoard();
    }

    # Print the appropriate success message
    if (!$nocheckstate) {
	print(GREEN, "Success: You can safely run disconnected.\n", RESET)
	    if $verbose;
    }
    else {
	print(GREEN, "Success: You can now run disconnected.\n", RESET)
	    if $verbose;
    }
}

#
# listparcels - list information about a user's parcels
#
sub listparcels () {
    my $line;
    my $item;
    my $lsargs;
    
    # Build the argument list for the server-side ls operation
    $lsargs = "";
    if ($parcel) {
	$lsargs = "-p $parcel";
    }
    if ($longvers) {
	$lsargs .= " -L $longvers";
    } elsif ($longflag) {
	$lsargs .= " -L $syscfg{ls_versions}";
    }

    # Run the remote ls program on the server.  Pass through server
    # errors without further comment.
    print "Parcels for $userid on server $server:\n";
    isr_srun($userid, "ls", "-u $userid $lsargs", "", 0);
}

#
# authenticate - Perform the SSH magic
#
sub authenticate () {
    mysystem("ssh -A -l $userid $server ssh-add") == 0
	or system_errexit("Unable to run ssh-add on the server ($server)");

    return 0;
}

#
# deauthenticate - Remove all SSH keys
#
sub deauthenticate () {

    mysystem("ssh-add -D") == 0
	or system_errexit("Unable to run \"ssh-add -D\" on local machine");

    return 0;
}

#
# release - Erase all traces of a parcel from the client and do a 
#           soft release (i.e., with nonce) of its lock.
#
sub release () {
    my $nonce;

    # This operation should not be interrupted by the user
    block_sigint();

    # Get the nonce
    if (!-e "$parceldir/nonce") {
	errexit("$parceldir/nonce does not exist.");
    }
    open(NONCE, "$parceldir/nonce")
        or errexit("Can't read $parceldir/nonce");
    $nonce = <NONCE>;
    close(NONCE);
    chomp($nonce);
    if (!$nonce) {
	err("Empty client nonce\n");
    }

    # Release the lock on the parcel using the nonce (soft release)
    print "Releasing parcel lock...\n"
	if $verbose;
    if (clean($nonce) == 0) {
	print(GREEN, "Success: Parcel $userid/$parcel is now checked in (and lock released).\n", RESET)
	    if $verbose;
    }

    return 0;
}

#
# hoard - Copy all server disk blocks to the local client cache
#
sub hoard () {
    my $parcelcfgfile; 

    # If the parcel is not currently checked out, then fetch a
    # temporary copy of parcel.cfg from the server, otherwise use
    # the parcel.cfg file hat was fetched during checkout

    $parcelcfgfile = "$parceldir/parcel.cfg";
    if (!-e $parceldir) {
	$parcelcfgfile = "$isrdir/$parcel-parcel.cfg.hoard";
	print "Fetching configuration data for $userid/$parcel from server.\n"
	    if $verbose;
	get_parcelcfg($parcelcfgfile);
    } 

    # Parse the config file
    %cfg = parse_parcelcfg($parcelcfgfile);

    # Delete the temporary parcel.cfg file if necessary
    if (!-e $parceldir) {
	unlink($parcelcfgfile);
    }

    # Run the actual hoard process
    do_hoard();

    # The hoard finished without any errors. Declare success
    print GREEN, "Success: The parcel $userid/$parcel is now fully hoarded on this host.\n", RESET
	if $verbose;
}

#
# checkparcel - Check a remote parcel for consistency
#
sub checkparcel () {
    my $versionflag;
    my $checkstateflag;
    
    #
    # Ask the server the to check the consistency of the parcel
    #
    $versionflag = "";
    if ($version) {
	$versionflag = "-v $version";
    }

    $checkstateflag = "";
    if ($checkstate) {
	$checkstateflag = "-c";
    }
    isr_srun($userid,
	     "checkparcel", 
	     "-u $userid -p $parcel -V $versionflag $checkstateflag",
	     "", 0) == 0
		 or errexit("There is something wrong with parcel $userid/$parcel on the server.");

    print(GREEN, "Success: The parcel $userid/$parcel on the server looks OK.\n", RESET)
	if $verbose;
}

#
# statparcel - Report general statistics about the cache and if requested, 
#              run a content consistency check on the chunks
#
sub statparcel () {
    my $memsize;
    my $cachestr = "";

    my @files = ();

    # Parse config file that was retrieved during checkout
    %cfg = parse_parcelcfg("$parceldir/parcel.cfg");

    #
    # Display the size of the memory image (if it exists)
    #
    if (-e "$cachedir/cfg") {
	opendir(DIR, "$cachedir/cfg") 
	    or unix_errexit("Unable to open $cachedir/cfg.");
	@files = grep(/\.vmem$/, readdir(DIR));
	closedir(DIR);
	if (@files > 0) {
	    $memsize = (stat("$cachedir/cfg/$files[0]")->size)/(1<<20);
	    printf("Memory image: %d MB (uncompressed)\n", $memsize);
	}
    }

    #
    # Display cache stats
    #
    $cachestr = "cache"
	if (-e $cachedir);
    isr_run_parcelkeeper("examine", "parcel last $cachestr hoard") == 0
	or errexit("Could not examine cache");
    
    #
    # Verify that each block in local cache has a valid keyring tag, if
    # requested
    #
    if ($checkstate == 1 or $checkstate == 2) {
	isr_run_parcelkeeper("validate", "parcel cache last") == 0
	    or errexit("Could not validate cache");
    }

    #
    # Check hoard cache for consistency (optional)
    #
    if ($checkstate == 1 or $checkstate == 3) {
	isr_checkhoard();
    }
}

#
# passwd - Change the user's ISR passwd on the server
#
sub passwd () {
    print "Changing password for ISR userid $userid:\n";
    mysystem("ssh -l $userid -t $server passwd") == 0
	or errexit("Unable to change ISR password.");
}

#
# resetclient - Resets the ISR runtime
#
sub resetclient () {
    my $vmname;
    my $vmopts;
    
    query("Really terminate all running ISR processes?") eq "y"
	or return;

    print("Terminating any Parcelkeeper processes.\n")
	if $verbose;
    system("killall parcelkeeper > /dev/null 2>&1");

    print("Terminating any VMware processes.\n")
	if $verbose;
    ($vmname, $vmopts) = split(" ", $syscfg{vmcommand});
    system("killall $vmname > /dev/null 2>&1");

    print("Terminating any ISR processes.\n")
	if $verbose;
    system("killall isr > /dev/null 2>&1");
}

#
# cleanclient - Remove all traces of a parcel's session state
#
sub cleanclient() {
    my $reply;

    # Give users a chance to change their minds.
    if ($verbose) {
	$reply = query("This command deletes local session state on this host. Proceed?");
	if ($reply eq "n") {
	    return;
	}
    }

    # Remove the parcel's session state
    print("Removing session state and releasing server lock...\n")
	if $verbose;
    if (clean(0) > 0) {
	return;
    }

    # Optionally remove the parcel's hoard cache, too
    if ($allflag) {
	print("Deleting hoard cache...\n")
	    if $verbose;
        # XXX
    }

    print(GREEN, "Success: Parcel $userid/$parcel erased from client and server lock released.\n", RESET)
	if $verbose;
}

#############################
# Section 3. Helper functions
#############################

#####
# Subcommand sanity checks
#

#
# Most commands require a parcel on the command line
#
sub need_parcel () {
    usage("Missing parcel name")
	if !$parcel;
    
    # 
    # Hack: the cases in which we need a parcel name are exactly the cases
    # in which we want to log.  (If we don't have a parcel name, we don't know
    # what log file to write to.)  So we start the log as a side-effect.
    #
    $log_enabled = 1;
    message("START", "OpenISR !!VERSION!!, revision $Isr::RCS_REVISION");
    message("ENTER", "@ARGV");
    message("BEGIN", $command);
}

#
# Some commands don't work on a particular parcel
#
sub need_not_parcel () {
    usage("\"$command\" does not take a parcel name")
	if $parcel;
}

#
# Some commands expect the parcel to already be checked out
#
sub need_checked_out () {
    errexit("Parcel $userid/$parcel not checked out. Checkout or resume first.")
	if (!-e "$isrdir/$parcel");
}

#
# Most commands require a network connection
#
sub need_network () {
     print "Checking network connection...\n"
	 if $verbose > 1;
     connected() 
	 or errexit("You do not appear to have a network connection: couldn't contact $server.");
}

#####
# Misc helper functions
# 

sub acquire_lock ($$) {
    my $file = shift;
    my $desc = shift;
    
    my $lockstruct;
    my $fh;
    
    # This is black magic.  We don't want to make assumptions about whether
    # we're using off_t or off64_t, or whether we're on a 64-bit architecture,
    # or whether Perl is compiled to support 64-bit ints (so we can't use
    # the "q" template flag).  Fortunately, we need to set both l_start
    # and l_len to zero, and there's nothing after that whose alignment
    # we care about.  So we just pad to the largest possible case, which
    # is off64_t, in 32-bit chunks.  We do, however, still make assumptions
    # about the ordering of the fields in the struct; there doesn't seem to
    # be any way around that.
    $lockstruct = pack("s!s!lllll", F_WRLCK, SEEK_SET);
    open($fh, ">", $file)
	or unix_errexit("Can't open $file for writing");
    if (!fcntl($fh, F_SETLK, $lockstruct)) {
	errexit("$desc locked by another process")
	    if ($! == EACCES or $! == EAGAIN);
	unix_errexit("Can't acquire lock");
    }
    push(@locks, {"NAME" => $file, "FH" => $fh});
}

sub release_locks () {
    my $record;
    
    while ($record = pop(@locks)) {
	unlink($record->{"NAME"});
	close($record->{"FH"});
    }
}

#
# clean - Erase all traces of a parcel from the client and do a soft
#         (with nonce) or hard (no nonce) release of its lock.
#
sub clean ($) {
    my $nonce = shift;     # nonce (optional)

    my $errors = 0;
    my $clientname = hostname();

    # Make sure the current working directory exists
    chdir($isrdir);
    
    # Now remove all traces of the parcel on the client and unlock it
    if (mysystem("rm -rf $parceldir") != 0) {
	err("Unable to remove $parcel.");
	$errors++;
    }

    # If the caller supplied a nonce, then request a soft release
    if ($nonce) {
	if (isr_srun($userid, 
		     "lock", 
		     "-p $userid/$parcel -n $clientname -r $nonce", 
		     "", 0) != 0) {
	    err("Unable to release lock for $parcel. Use 'isr clean' to force the release.");
	    $errors++;
	}
    }

    # No nonce supplied, request a hard release
    else {
	if (isr_srun($userid, "lock", 
		 "-p $userid/$parcel -n $clientname -R", "", 0) != 0) {
	    errexit("Unable to release lock for $parcel.");
	    $errors++;
	}
    }

    return $errors;
}

#
# do_hoard - repeatedly call isr_hoard() protocol method until fully hoarded
#
sub do_hoard () {
    my $retval;
    
    # Ask the system to hoard all hdk blocks into local store. If the
    # hoard operation returns an error code, then either the network
    # connection is down, the server is down, a chunk in the hoard
    # somehow got corrupted, or a concurrent checkin created a new
    # version on the server while the hoard was underway. In any case,
    # we will restart the hoard operation until it succeeds.
    while (1) {
	$retval = isr_hoard();
	if ($retval == $Isr::ESUCCESS) {
	    last; 
	} elsif ($retval == $Isr::EINTR) {
	    errexit("Interrupted");
	}
	print "Sleeping $syscfg{hoard_sleep} secs before restarting hoard...\n"
	    if $verbose;
	sleep($syscfg{hoard_sleep});
    }
}

#
# get_parcelcfg - Retrieve parcel configuration file from the server
#
sub get_parcelcfg ($) {
    my $outfile = shift; # Put the retrieved file here

    if (mysystem("ssh -l $userid $server $Isr::ISRSERVERBIN/isr_srv_getconfig.pl -p $parcel > $outfile")) {
	unlink($outfile);
	system_errexit("Parcel $userid/$parcel does not exist on the server ($server).");
    }
}

#
# get_motd - Read message-of-the-day from the server and print it out
#
sub get_motd () {
    mysystem("ssh -l $userid $server $Isr::ISRSERVERBIN/isr_srv_motd.pl -p $parcel -u $userid") == 0
	or system_err("Couldn't read message of the day from the server ($server).");
}

#
# parse_cfgfile - Read a file consisting of key=value pairs (and possibly
#                 comments) and add them to the hash whose ref is provided by
#                 the caller, overriding existing values with the same keys.
#                 The hash is also tied to IsrConfigTie if not already tied.
#                 Returns 0 on error, 1 otherwise.
#
sub parse_cfgfile ($$) {
    my $infile = shift;
    my $hashref = shift;

    my $line;
    my $key;
    my $value;

    # Cause accesses to nonexistent keys to call errexit()
    tie(%$hashref, "IsrConfigTie")
        if (!tied(%$hashref));
    
    # Load the key/value pairs into the hash
    unless (open(INFILE, $infile)) {
	# If the hash already has keys in it, then we're only trying to
	# override existing defaults, so we don't warn if the cfgfile doesn't
	# exist
	unix_err("Config file $infile not found")
	    if (!scalar %$hashref);
	return 0;
    }
    while ($line = <INFILE>) {
	chomp($line);

	# Skip comment lines
	if ($line =~ /^\s*\#/) {
	    next;
	}

	# Otherwise parse out key and value
	($key, $value) = split(/\s*=\s*/, $line);
	if (defined $value) {
	    $hashref->{$key} = $value;
	}
    }
    unless (close(INFILE)) {
	unix_err("Unable to close $infile");
	return 0;
    }

    # Return success
    return 1;
}

#
# parse_parcelcfg - Read a local parcel.cfg file and return a hash containing 
#                   its key/value pairs. Delete the file if there are any
#                   problems.
#
sub parse_parcelcfg ($) {
    my $infile = shift;

    my %cfg;

    # Load the key/value pairs into the hash
    if (!parse_cfgfile($infile, \%cfg)) {
	unlink($infile);
	errexit("Couldn't parse parcel.cfg for $userid/$parcel");
    }
    
    # Check parcel format version
    unless (exists $cfg{VERSION} and $cfg{VERSION} == 3) {
	unlink($infile);
	errexit("Unknown or missing VERSION in parcel.cfg for parcel $userid/$parcel.");
    }

    # Every parcel has a PROTOCOL entry
    unless (exists $cfg{PROTOCOL}) {
	unlink($infile);
	errexit("Missing PROTOCOL entry in parcel.cfg for parcel $userid/$parcel.");
    }

    # Every parcel has a MAXKB entry
    unless (exists $cfg{MAXKB}) {
	unlink($infile);
	errexit("Missing MAXKB entry in parcel.cfg for parcel $userid/$parcel.");
    }

    unless (exists $cfg{RPATH}) {
	unlink($infile);
	errexit("Missing RPATH entry in parcel.cfg for parcel $userid/$parcel.");
    }
    
    unless (exists $cfg{WPATH}) {
	unlink($infile);
	errexit("Missing WPATH entry in parcel.cfg for parcel $userid/$parcel.");
    }
    
    unless (exists $cfg{KEYROOT}) {
	unlink($infile);
	errexit("Missing KEYROOT entry in parcel.cfg for parcel $userid/$parcel.");
    }
    
    unless (exists $cfg{SERVER}) {
	unlink($infile);
	errexit("Missing SERVER entry in parcel.cfg for parcel $userid/$parcel.");
    }
    
    # Every read and write path gets appended with the userid and parcel
    $cfg{RPATH} .= "/$userid/$parcel";
    $cfg{WPATH} .= "/$userid/$parcel";

    # Return the hash of key/value pairs to the caller
    return %cfg;
}

#
# build_cache - Create a local Parcelkeeper cache if one doesn't exist already
#
sub build_cache () {
    my $name;

    if (!-e $cachedir) {
	mktree($cachedir)
    	    or errexit("Unable to make $cachedir");
    }

    # Copy the virtualization files from lastdir to cachedir
    if (!-e "$cachedir/cfg") {
	print("Copying virtual machine memory image...\n")
	    if $verbose;
	
	mkdir("$cachedir/cfg")
	    or unix_errexit("Unable to make $cachedir/cfg");
	opendir(DIR, "$lastdir/cfg")
	    or unix_errexit("Unable to read memory image directory $lastdir/cfg");
	foreach $name (readdir(DIR)) {
	    next if ($name eq "." || $name eq "..");
	    copy("$lastdir/cfg/$name", "$cachedir/cfg/$name")
		or unix_errexit("Unable to copy $name from $lastdir/cfg to $cachedir/cfg.");
	}
	closedir(DIR);
    }

    # Copy the keyring files
    if (!-e "$cachedir/keyring") {
	copy("$lastdir/keyring", "$cachedir/keyring")
	    or unix_errexit("Unable to copy $lastdir/keyring");
    }
}

#
# hdksize - Returns the number of chunks present in the local cache
#
sub hdksize () {
    my $numchunks;

    my $imageindex = "$cachedir/disk.idx";

    # cache is trivially empty
    return 0
        if ! -e $imageindex;

    # Determine how many chunks are in the local cache
    # XXX
    open(IN, "-|", "$Isr::LIBDIR/query", $imageindex, "SELECT count(*) from chunks")
        or unix_errexit("Unable to read $imageindex");
    $numchunks = <IN>;
    close IN && $? == 0
        or errexit("Unable to query $imageindex");
    
    return int($numchunks);
}

#
# connected - Returns true if the client has a network connection.
#             We have to fork a child and timeout on the wait() 
#             because the bind client coopts SIGALRM signals. 
#
sub connected () {
    my $pid;
    my $childpid;
    my $eval_result;

    $pid = fork();

    # The child tries to establish a connection with root serve
    if ($pid == 0) {
	$no_shutdown = 1;
	my $socket = IO::Socket::INET->new(PeerAddr => $server,
					   PeerPort => "22",
					   Proto    => "tcp",
					   Type     => SOCK_STREAM);
	exit;
    }

    # The parent waits a few seconds for the child to complete, then times out
    $SIG{'ALRM'} = sub {die "timeout"};
    alarm($syscfg{connect_timeout});
    eval {
	waitpid($pid, 0);
    };

    # Determine if the child established a connection in the allotted time.
    alarm(0);
    $eval_result = $@;
    if ($eval_result =~ /timeout/) {
	kill(9, $pid);
	return 0;
    }
    else {
	return 1;
    }
}

#
# check_nexus_version - print a warning if the Nexus release number is older
#                       than our own
#
sub check_nexus_version () {
    my $nexus_version;
    my $nexus_major;
    my $nexus_minor;
    my $nexus_patch;
    my $isr_version = "!!VERSION!!";
    my $isr_major;
    my $isr_minor;
    my $isr_patch;
    my $warn = 0;
    
    if (!-e "/sys/class/openisr/release") {
	print YELLOW, "The OpenISR kernel module is out of date.  Please run 'openisr-config' as root.\n", RESET;
	message("INFO", "Nexus is out of date (<=0.8.3 vs. $isr_version)");
	return;
    }
    open(NEX, "/sys/class/openisr/release")
    	or errexit("Couldn't read Nexus release attribute");
    $nexus_version = <NEX>;
    close(NEX);
    chomp $nexus_version;
    ($nexus_major, $nexus_minor, $nexus_patch) = split(/\./, $nexus_version);
    ($isr_major, $isr_minor, $isr_patch) = split(/\./, $isr_version);
    if ($isr_major >= $nexus_major) {
	if ($isr_major > $nexus_major) {
	    $warn = 1;
	} elsif ($isr_minor >= $nexus_minor) {
	    $warn = 1
	        if ($isr_minor > $nexus_minor or $isr_patch > $nexus_patch);
	}
    }
    if ($warn) {
	print YELLOW, "The OpenISR kernel module is out of date.  Please run 'openisr-config' as root.\n", RESET;
	message("INFO", "Nexus is out of date ($nexus_version vs. $isr_version)");
    }
}

#
# get_parcelkeeper_pid - Returns the PID of the Parcelkeeper background
#                        process associated with this parcel, or zero if none
#                        are running.
#
sub get_parcelkeeper_pid () {
    my $pidfile = "$isrdir/$parcel/cache/parcelkeeper.pid";
    my $pid;
    
    -e $pidfile or return 0;
    open(PIDFILE, $pidfile) or return 0;
    defined($pid = <PIDFILE>) or return 0;
    close(PIDFILE);
    chomp($pid);
    # Make sure the process is still alive
    kill(0, $pid) or return 0;
    return $pid;
}

#
# block_sigint - Block receipt of SIGINT (ctrl-c) and return sigmask
# 
sub block_sigint () {
    my $sigset = POSIX::SigSet->new(SIGINT);

    sigprocmask(SIG_BLOCK, $sigset)
	or errexit("Could not block SIGINT");
    return $sigset;
}

#
# unblock_sigint - Unblock receipt of SIGINT
#
sub unblock_sigint ($) {
    my $sigset = shift;

    sigprocmask(SIG_UNBLOCK, $sigset) 
	or errexit("Could not unblock SIGINT");
}

#
# block_sigtstp - Block receipt of SIGTSTP (ctrl-z) and return sigmask
# 
sub block_sigtstp () {
    my $sigset = POSIX::SigSet->new(SIGTSTP);

    sigprocmask(SIG_BLOCK, $sigset)
	or errexit("Could not block SIGTSTP");
    return $sigset;
}

#
# mysystem - Version of Unix 'system' function that can be 
#            interrupted with ctrl-c
#
sub mysystem ($) {
    my $cmd = shift;

    if (!defined($pid = fork())) {
	unix_errexit("Unable to fork in mysystem");
    } 

    # Child
    elsif ($pid == 0) {
	$no_shutdown = 1;
	exec($cmd)
	    or unix_errexit("Unable to exec $cmd in mysystem");
    } 

    # Parent
    waitpid($pid, 0);
    return $?; # Return exit status of the child
}

#
# sys_sync - Call sync(2)
#
sub sys_sync () {
    if ($Config{'myarchname'} =~ /i.86-linux/ and SYS_sync() == 162) {
	# On Ubuntu Feisty on 32-bit x86, SYS_sync() reports the syscall number
	# for sync() on the AMD64 architecture, which is not the same number.
	# In this case syscall(&SYS_sync) is actually a call to nanosleep()
	# with garbage arguments, which hangs forever.  So we hardcode the
	# syscall number for this case.
	syscall(36);
    } else {
	syscall(&SYS_sync);
    }
}

#
# mktree - Make the directory named by the argument, and all of its parents.
#          Returns true if successful or the directory already exists, false
#          on error.
#
sub mktree ($) {
    my $tree = shift;
    
    # mkpath() throws a fatal error on failure, so we have to trap it
    eval {mkpath($tree)};
    return 0 if $@;
    return 1;
}

######
# Error reporting routines
#

#
# err - Print an error message without exiting
#
sub err ($) {
    my $msg = shift;

    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print "[$progname] Warning: $msg\n";
    message("ERROR", "[$progname] Warning: $msg");
}

#
# unix_err - Print an error message (with Unix strerr)
#
sub unix_err ($) {
    my $msg = shift;

    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print "[$progname] Warning: $msg ($!)\n";
    message("ERROR", "[$progname] Warning: $msg");
}

#
# errexit - Print an error message and exit
#
sub errexit ($) {
    my $msg = shift;

    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print RED, "[$progname] Error: $msg\n", RESET;
    message("ERROR", "[$progname] Error: $msg");
    exit $Isr::EINVAL;
}

#
# unix_errexit - Print an error message (with Unix strerr) and exit
#
sub unix_errexit ($) {
    my $msg = shift;

    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    print RED, "[$progname] Error: $msg ($!)\n", RESET;
    message("ERROR", "[$progname] Error: $msg ($!)");
    exit $Isr::EINVAL;
}

#
# system_err - Print an error after the system() function fails
#
sub system_err ($) {
    my $msg = shift;

    my $exit_value = $? >> 8;
    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    # $? is the wait() style return value. $! is strerr[errno]
    # $exit_value  = $? >> 8;
    # $signal_num  = $? & 127;
    # $dumped_core = $? & 128;
    print RED, "[$progname] Error: $msg\n", RESET;
    message("ERROR", "[$progname] Error: $msg");
    
    # Pass the exit value back to the caller
    return $exit_value; 
}

#
# system_errexit - Print an error and exit after the system() function fails
#
sub system_errexit ($) {
    my $msg = shift;
    
    exit system_err($msg);
}

#
# message - Emits a message to the ISR client side session log
#
sub message($$) {
    my $event = shift;
    my $msg = shift;

    my $date = localtime();
    my $string;
    my $isrdir;

    return
        if !$log_enabled;
    $string = message_string();
    $isrdir = "$ENV{HOME}/.isr/$userid";
    open(LOG, ">>$isrdir/$parcel.log")
	or return;
    print LOG "$date|$event|$string|$msg\n";
    close(LOG);
}

#
# message_string - returns the inner fields of a log message string
#
sub message_string {
    my $hostname = hostname();

    return "$$|$hostname|$sessionid";
}

#
# query - Ask the user a question and return the reply
#
sub query {
    my $question = shift;

    my $reply;

    print RED, "$question (y/n): ", RESET;
    $reply = <STDIN>;
    chomp($reply);

    # Keep asking until the user replies either y or n
    while ($reply ne "y" and $reply ne "n") {
	print RED, "$question (y/n): ", RESET;
	$reply = <STDIN>;
	chomp($reply);
    }
    return $reply;
}

#
# mypause - Pause and then continue on 'y' and exit on 'n'
#
sub mypause($) {
    my $msg = shift;

    my $reply;

    if ($verbose > 1) {
	$reply = query($msg);
	if ($reply eq "n") {
	    exit;
	}
    }
}

#
# usage - Print help message and terminate.  usage("") is special: it prints
#         the long-form help.
#
sub usage ($) {
    my $msg = shift;
    my $progname;

    # Strip any path information from the program name
    ($progname = $0) =~ s#.*/##s; 

    if ($msg) {
        print RED, "Error: $msg\n", RESET;
    }

    print RED, "Usage: $progname command [parcel] [options...]\n", RESET;
    print BLUE, "Commands: auth, checkin (ci), checkout (co), checkp, clean, deauth, discard,\n", RESET;
    print BLUE, "          disconnect, help, hoard, ls, passwd, reset, resume, stat, sync,\n", RESET;
    print BLUE, "          version\n", RESET;
    print BLUE, "Parcel is required for most commands\n", RESET;
    if (!$msg) {
	print "Basic commands:\n";
	print "  auth       Authenticate to the ISR server (once per X session only).\n";
	print "  checkin    Sync parcel to server and release lock (-b optional).\n";
	print "  checkout   Fetch parcel from server and acquire its lock (-r optional).\n";
	print "  checkp     Check parcel on server for consistency (-r and -c optional).\n";
	print "  clean      Remove parcel from client and release its lock (-a optional).\n";
	print "  deauth     Remove authentication credentials from your client.\n";
	print "  discard    Discard all local changes to parcel since last checkout or sync.\n";
	print "  disconnect Prepare the client to run a parcel disconnected (-x optional).\n";
	print "  help       Print help message.\n";
	print "  hoard      Fetch entire virtual disk so you can run disconnected.\n";
	print "  ls         List info about your parcels (parcel, -l and -L optional).\n";
	print "  passwd     Change your ISR password on the server.\n";
 	print "  reset      Reset ISR runtime.\n";
 	print "  resume     Checkout (if necessary) and run a parcel (-r and -d optional).\n";
	print "  stat       Display information about local ISR state (-c optional).\n";
	print "  sync       Make new parcel version on server w/o releasing lock (-b optional).\n";
	print "  version    Print ISR version.\n";
    }
    print "Options:\n";
    print "  -a,--allstate      Remove all hoarded state from client [clean].\n";
    print "  -b,--bwlimit       Bandwidth limit (KBytes/s) [ci, sync].\n";
    print "  -c,--checkstate    Do additional consistency check [checkp, stat].\n";
    print "  -d,--disconnected  Run disconnected (after hoarding) [resume].\n";
    print "  -l,--long          Long listing with default number of versions [ls].\n";
    print "  -L,--longvers      Long listing with specific number of versions [ls].\n";
    print "  -q,--quiet         Run silently (except if things go wrong).\n";    
    print "  -r,--rollback      Rollback to or check version [co, checkp].\n";
    print "  -s,--server        Server domain name (optional).\n";
    print "  -u,--user          Your ISR user name (defaults to your login name).\n";    
    print "  -v,--verbose       Increment verbosity level.\n";
    print "  -x,--nocheckstate  Skip consistency check [ci, sync, disconnect].\n";
    print "  -X,--noauto        Don't automatically start/stop VMware [resume].\n";
    print "\n";
    
    exit 0;
}

#######################################################################
# HTTPSSH - Distributed storage system module (HTTP/SSH version)
#######################################################################

#############################
# Section 1: Public functions
#############################

#
# isr_sget - Copy a file from remote store to local store.  The client will
#            ignore SIGINT/SIGQUIT while the transfer is in progress;
#            $Isr::EINTR will be returned if one of these was received by
#            the child process.
#
sub isr_sget ($$$$) {
    my $userid = shift;    # ISR userid
    my $frompath = shift;  # protocol-independent server "from" suffix 
    my $topath = shift;    # local "to" path name
    my $progmeter = shift; # print a progress meter

    my $i;
    my $retval;
    my $flag;
    
    $flag = "-sS";    
    if ($progmeter and $verbose) {
	$flag = "";
    }
	
    # Retry if the get operation fails
    for ($i = 0; $i < $syscfg{retries}; $i++) {
	$retval = system("curl --connect-timeout $syscfg{connect_timeout} $flag -f -G $cfg{RPATH}/$frompath > $topath");
	if ($retval == 0) {
	    return ($Isr::ESUCCESS);
	}
	if (WIFSIGNALED($retval)) {
	    # curl process killed by signal.  Don't retry.
	    return $Isr::EINTR;
	}
	print "[isr] get operation failed. Retrying...\n"
	    if $verbose;
	sleep(1);
    }
    return ($retval);
}

#
# isr_srun - Perform an operation on parcel tree in remote store
#
sub isr_srun ($$$$$) {
    my $userid = shift;   # user name
    my $operation = shift;# requested operation
    my $args = shift;     # argument string
    my $outfile = shift;  # where to store stdout command output  (optional)
    my $stderr = shift;   # if true, redirect stderr to outfile (optional)
    
    my $retval;
    my $command = "isr_srv_" . $operation . ".pl"; 
    my $redirect = "";

    # Redirect stderr to outfile if requested
    if ($stderr) {
	$redirect = "2>&1";
    }

    # Perform the operation on remote storage
    if ($outfile) {
	$retval = mysystem("ssh -l $userid $server $Isr::ISRSERVERBIN/$command $args > $outfile $redirect");
    }
    else {
	$retval = mysystem("ssh -l $userid $server $Isr::ISRSERVERBIN/$command $args");
    }
    return $retval;
}

#
# isr_connected_parcel - Return true if parcel exists in remote store
#
sub isr_connected_parcel () {
    isr_srun($userid, "ls", 
	     "-u $userid -p $parcel", "/dev/null", 1) == 0
		 or return 0;
    return 1;
}

#
# isr_connected_http - Return true if client can talk to remote store
#
sub isr_connected_http () {

    if (IO::Socket::INET->new(PeerAddr => $server,
			      PeerPort => "80",
			      Proto    => "tcp",
			      Type     => SOCK_STREAM)) {
	return 1;
    }
    else {
	return 0;
    }
}

#
# isr_run_parcelkeeper - Run the Parcelkeeper process and return its
#                        exit status.
#
sub isr_run_parcelkeeper ($$) {
    my $mode = shift;
    my $args = shift;
    
    my $logstring = "|PARCELKEEPER|" . message_string() ."|";
    my $cmd = "$Isr::LIBDIR/parcelkeeper $mode";
    my $arg;
    my $do_log = 0;
    
    foreach $arg (split(/\s+/, $args)) {
	if ($arg eq "parcel") {
	    $cmd .= " --parcel $parceldir";
	} elsif ($arg eq "cache") {
	    $cmd .= " --cache $cachedir";
	} elsif ($arg eq "last") {
	    $cmd .= " --last $lastdir";
	} elsif ($arg eq "dest") {
	    $cmd .= " --destdir $tmpdir/cache/hdk";
	} elsif ($arg eq "hoard") {
	    $cmd .= " --hoard $hoarddir";
	} elsif ($arg eq "compression") {
	    $cmd .= " --compression $syscfg{compression}";
	} elsif ($arg eq "log") {
	    $do_log = 1;
	} else {
	    errexit("Unknown parcelkeeper parameter $arg");
	}
    }
    
    if ($do_log) {
	$cmd .= " --log $parceldir/../$parcel.log '$logstring' $syscfg{logmask} $syscfg{console_logmask}";
    } else {
	$cmd .= " --log /dev/null '' 0x0 $syscfg{console_logmask}";
    }

    #
    # Crank up PK with all the right arguments
    #
    if ($mode eq "run") {
	# Don't allow SIGINT
        return system($cmd);
    } else {
	return mysystem($cmd);
    }
}

#
# isr_hoard - Block until the parcel is cached locally
# 
sub isr_hoard () {
    #
    # If we don't have a local keyring on this host, then retrieve
    # it from the server into a temporary 'last' directory
    #
    if (!-e "$lastdir/keyring") {

	# Assign a temporary 'last' directory and clean any existing
	# temp files for this user and parcel
	$lastdir = "$isrdir/tmplast-$userid-$parcel-$$";
	mysystem("rm -rf $isrdir/tmplast-$userid-$parcel*");

	# Before going any further, make sure we have a protocol level
	# connection to the server and a valid parcel
	if (!isr_connected_http()) {
	    errexit("The server appears to be down.");
	}
	if (!isr_connected_parcel()) {
	    errexit("Remote parcel $userid/$parcel not found on the server.");
	}

	# Fetch the encrypted keyring into the last dir
	print("Fetching keyring from the server.\n")
	    if $verbose;
	mktree($lastdir)
	    or errexit("Unable to make $lastdir");
	unlink("$lastdir/tmpfile");
	if (isr_sget($userid, "last/keyring.enc", "$lastdir/tmpfile", 0) != $Isr::ESUCCESS) {
	    mysystem("rm -rf $lastdir");
	    errexit("Unable to fetch keyring.enc");
	}
	if (!rename("$lastdir/tmpfile", "$lastdir/keyring.enc")) {
	    mysystem("rm -rf $lastdir");
	    unix_errexit("Unable to commit $lastdir/keyring.enc");
	}

	# Save the keyroot in the parcel directory (otherwise we would
	# need to include the actual keyroot on the command line)
	if (open(KEYROOT, ">$lastdir/keyroot") == 0) { 
	    mysystem("rm -rf $lastdir");
	    unix_errexit("Unable to open $lastdir/keyroot for writing");
	}
	print KEYROOT $cfg{KEYROOT};
	close(KEYROOT);

	# Decrypt the keyring
	if (mysystem("openssl enc -d -aes-128-cbc -in $lastdir/keyring.enc -out $lastdir/keyring -pass file:$lastdir/keyroot -salt") != 0) {
	    mysystem("rm -rf $lastdir");
	    errexit("Unable to decrypt keyring.enc");
	}
	unlink("$lastdir/keyring.enc");

	# Keyroot no longer needed, get rid of it
	unlink("$lastdir/keyroot");
    }

    # 
    # Fetch any chunks that are missing from the hoard cache from the server
    #
    print("Hoarding any missing disk blocks from the server...\n")
	if $verbose;
    
    # XXX

    # Fetch the chunk into a temporary file in the hoard cache. If
    # the sget fails after its retries, return an error code to the
    # caller so that it can retry the entire hoard operation. 
    # IMPORTANT: this higher level retry allows us to run hoard 
    # concurrent with checkin operations. During a commit on the
    # server from version k to k+1, most chunks are removed from
    # version k into k+1. When this happens during an sget, the
    # requested chunk no longer exists, so we need to rerun the 
    # hoard operation.
    
    return $Isr::ESUCCESS;
}

#
# isr_stathoard - Report the number of chunks in the hoard cache
# 
sub isr_stathoard () {
    my $numchunks = 0;
    
    # XXX
    
    return $numchunks;
}

#
# isr_sync - Make local state clean
#
sub isr_sync ($) {
    my $releasing = shift;  # whether we're releasing the lock afterward

    # Garbage collect the hoard cache
    isr_priv_cleanhoard();

    # Upload the dirty blocks in a cache directory on the server
    isr_priv_upload() == $Isr::ESUCCESS
	or errexit("Upload of parcel $userid/$parcel failed.");

    # Operations from this point on should not be interrupted by the user
    block_sigint();

    # Commit the dirty blocks to a new version
    isr_priv_commit($releasing) == $Isr::ESUCCESS
	or errexit("Commit of parcel $userid/$parcel failed.");

    # If $releasing == 1, it is not safe to unblock SIGINT until the parceldir
    # is removed by our caller, since the last/ dir is not up-to-date.

    return $Isr::ESUCCESS;
}

#
# isr_checkhoard - Reports on the consistency of the hoard cache
# 
sub isr_checkhoard () {
    print "Checking hoard cache for internal consistency...\n"
	if $verbose;
    
    # XXX

    #
    # If we get this far, everything is OK
    #
    return $Isr::ESUCCESS;
}

#####################################
# Section 2: Private helper functions
#####################################

#
# isr_priv_upload - Upload a copy of the parcel to temp cache on the server.
#          Note: Upload is idempotent. You can run it over and over again 
#          until it works.
#
sub isr_priv_upload () {
    my $dirtybytes = 0;
    my $dirtyblocks = 0;
    my $virtualbytes;
    my $vflag = "-q";
    my $bwflag = "";
    my $i;

    #
    # Check to see if there is anything to upload
    #
    if (!-e $cachedir) {
	print "Local cache is empty. Nothing to upload.\n"
	    if $verbose;
	return $Isr::ESUCCESS;
    }

    #
    # Before going any further, make sure we have a protocol level 
    # connection to the server and a consistent parcel
    # 
    if (!isr_connected_http()) {
	errexit("The server appears to be down.");
    }
    if (!isr_connected_parcel()) {
	errexit("The remote parcel $userid/$parcel is not available.");
    }

    #
    # We expect either all or none of the cache files
    #
    
    # XXX
    if (-e "$cachedir/keyring" and 
	-e "$cachedir/cfg") {
	# OK
    }
    else {
	if (-e "$cachedir/keyring" or 
	    -e "$cachedir/cfg") {
	    errexit("Inconsistent cache directory $cachedir");
	}
    }

    #
    # Copy the dirty parcel state to a temporary dirty cache
    # directory.  When the operation is finished, create a consistent
    # dirty cache flag on disk that tells us that the dirty cache is
    # consistent with the local cache, and thus the copy operation can
    # be skipped if the subsequent upload operation is
    # interrupted. This is an optimization that eliminates unnecessary
    # compress and encrypt operations, and better exploits the features
    # of rsync if the upload is interrupted and has to be restarted
    # (mainly because tar is not idempotent).
    #
    if (!-e $cdcache_file) {
	($dirtybytes, $dirtyblocks) = copy_dirtychunks();
	open(FLAG, ">$cdcache_file")
	    or unix_errexit("Unable to create dirty cache flag ($cdcache_file)");
	close FLAG;
    }
    else {
	print("Skipping local copy operation.\n")
	    if $verbose;
    }

    mypause("Done with local copy, ready to upload: hit y to continue");

    # 
    # Transfer the dirty local cache state to the server
    #
    print("Sending modified disk state to server...\n")
	if $verbose;
    $vflag = "--progress"
        if ($verbose);
    $bwflag = "--bwlimit=$bwlimit"
	if ($bwlimit);

    # Retry if the upload fails
    for ($i = 0; $i < $syscfg{retries}; $i++) {
	last
	    if mysystem("rsync -e ssh --delete --partial --recursive -z $vflag $bwflag $tmpdir/cache/ $userid\@$cfg{WPATH}/cache") == 0;
	print "[isr] upload failed. Retrying...\n"
	    if $verbose;
    }
    errexit("Upload failed. Aborting.")
        if $i == $syscfg{retries};
    mypause("Done with upload, ready to commit: hit y to continue");

    #
    # Log the number of hdk bytes that were transferred
    #
    $virtualbytes = $dirtyblocks*$cfg{CHUNKSIZE};
    message("INFO", "upload:hdk:$dirtybytes:$virtualbytes");

    # We need to do this, so that if the commit doesn't finish
    # rsync doesn't blow everything away
    unlink($cdcache_file);

    # Return successful status
    print("Upload completed, all updates have been sent to the server.\n")
	if $verbose;

    return $Isr::ESUCCESS;
}

#
# copy_dirtychunks - Build temp cache tree and populate it with dirty state
#
sub copy_dirtychunks () {
    my $tarsize = 0;
    
    my $dirtyblocks;
    my $dirtybytes;
    my $target;
    my $curfile;
    my $stat;

    #
    # Build an empty temporary cache directory structure on the client
    #
    mysystem("rm -rf $tmpdir");
    mktree("$tmpdir/cache/hdk")
	or errexit("Unable to make temporary directory $tmpdir/cache/hdk");

    #
    # Save a copy of the keyroot in the cache (otherwise we would
    # need to include the actual keyroot on the command line, which
    # would not be secure)
    #
    open(KEYROOT, ">$cachedir/keyroot") 
	or errexit("Unable to open $cachedir/keyroot for writing");
    print KEYROOT $cfg{KEYROOT};
    close(KEYROOT);

    #
    # Figure out (roughly) how large the cfg tarball will be, so that we can
    # generate a progress bar
    #
    opendir(CFG, "$cachedir/cfg")
	or unix_errexit("Couldn't read memory image directory $cachedir/cfg");
    foreach $curfile (readdir(CFG)) {
	next if ($curfile eq "." || $curfile eq "..");
	$stat = stat("$cachedir/cfg/$curfile");
	unix_errexit("Couldn't stat $cachedir/cfg/$curfile")
	    if !$stat;
	$tarsize += $stat->size;
    }
    closedir(CFG);
    
    #
    # Create cfg tarball and encrypt it and the keyring
    #
    print("Compressing and encrypting virtual machine memory image...\n")
	if $verbose;
    chdir($cachedir);
    mysystem("tar c cfg | pv -peW -s $tarsize | gzip -c | openssl enc -aes-128-cbc -out $tmpdir/cache/cfg.tgz.enc -pass file:$cachedir/keyroot -salt") == 0
	or system_errexit("Unable to create cfg.tgz.enc.");
    printf("Compressed size: %d MB\n", (stat("$tmpdir/cache/cfg.tgz.enc")->size)/(1<<20))
    	if $verbose;
    mysystem("openssl enc -aes-128-cbc -in $cachedir/keyring -out $tmpdir/cache/keyring.enc -pass file:$cachedir/keyroot -salt") == 0
	or system_errexit("Unable to encrypt keyring.");
    foreach $target ("cfg.tgz", "keyring") {
	message("INFO", 
		sprintf("upload:$target.enc:%d:", 
			stat("$tmpdir/cache/$target.enc")->size));
    }

    # Get rid of keyroot, no longer needed
    unlink("$cachedir/keyroot"); 

    # 
    # Copy any dirty hdk chunks to the temporary cache directory
    #
    print("Collecting modified disk state...\n")
	if $verbose;
    isr_run_parcelkeeper("upload", "parcel cache last dest hoard") == 0
    	or errexit("Unable to copy chunks to temporary cache dir");
    # Hack to get stats from PK
    open(STATFILE, "$tmpdir/cache/hdk/stats");
    chomp($dirtyblocks = <STATFILE>);
    chomp($dirtybytes = <STATFILE>);
    close STATFILE;
    unlink("$tmpdir/cache/hdk/stats");

    #
    # For record keeping, the caller needs to know how many total hdk bytes
    # and total hdk blocks were transferred.
    #
    return ($dirtybytes, $dirtyblocks);
}

#
# isr_priv_commit - Commit files that were copied to server-side 
#                   cache by upload
#
sub isr_priv_commit ($) {
    my $releasing = shift;

    #
    # Check to see if there is anything to upload
    #
    if (!-e $cachedir) {
	print "Local cache is empty. Nothing to commit.\n"
	    if $verbose;
	return $Isr::ESUCCESS;
    }

    #
    # Before going any further, make sure we have a protocol level 
    # connection to the server and a consistent parcel.
    # 
    if (!isr_connected_http()) {
	errexit("The server appears to be down.");
    }
    if (!isr_connected_parcel()) {
	errexit("The remote parcel is not available.");
    }

    # If requested, check the current version of the parcel for consistency
    if (!$nocheckstate) {
	isr_srun($userid,"checkparcel", "-u $userid -p $parcel", "", 0) == 0
	    or errexit("There is something wrong with the remote parcel. Aborting with no change to the remote parcel.");
    }

    #
    # Trigger the server-side commit. For rsync version, do not delete
    # the server-side cache directory after the commit finishes.
    #
    if (-e $cachedir) {
        print("checking uploaded cache dir before committing...\n");
	isr_srun($userid, "checkparcel", "-s -u $userid -p $parcel", "", 0) == 0
	    or errexit("Something went wrong during upload.  Aborting with no change to the remote parcel.\n");
	print("Committing updates on server...\n")
	    if $verbose;
	message("INFO", "Begin server side commit");
	isr_srun($userid, "commit", "-u $userid -p $parcel", "", 0) == 0
	    or errexit("Server-side commit of parcel $userid/$parcel failed.");
	message("INFO", "End server side commit");
    }

    # If requested, check the newly committed version for consistency
    if (!$nocheckstate) {
	isr_srun($userid, "checkparcel", "-u $userid -p $parcel", "", 0) == 0
	     or errexit("Something went wrong during commit.  Remote parcel is inconsistent.");
    }

    #
    # If the server-side commit was successful, then do the
    # client-side commit. 
    print "Committing updates on client...\n"
	if $verbose;
    isr_priv_clientcommit($releasing);

    return $Isr::ESUCCESS;

}

#
# isr_priv_clientcommit - Commit state on the client.  First, copy the
#     memory image and keyring from cache/ to last/, so that the
#     client-side last remains consistent with the server-side last/.
#     Second, move any dirty hdk chunks from the local cache to the hoard
#     cache so that the hoard cache stays fully populated.
#
sub isr_priv_clientcommit($) {
    my $releasing = shift;

    my $dirtyblocks = 0;
    my $name;
    my $sha1value;

    #
    # Now that we have determined the dirty disk state, we can copy
    # the memory image and keyring from cache to last
    #
    if ($releasing) {
	# There's no point in copying the memory from cache/ to last/ if the
	# whole directory tree is going to be removed.  SIGINT is blocked, and
	# must remain blocked until the lock is released.
	message("INFO", "Client side commit - skipping copy of memory image");
    } else {
	message("INFO", "Client side commit - start copying memory image");
	opendir(DIR, "$cachedir/cfg")
	    or unix_errexit("Unable to read memory image directory $cachedir");
	foreach $name (readdir(DIR)) {
	    next if ($name eq "." || $name eq "..");
	    copy("$cachedir/cfg/$name", "$lastdir/cfg/$name")
		or unix_errexit("Unable to copy $name from $cachedir/cfg to $lastdir/cfg.");
	}
	closedir(DIR);
	copy("$cachedir/keyring", "$lastdir/keyring")
	    or unix_errexit("Unable to copy keyring from $cachedir to $lastdir.");
	message("INFO", "Client side commit - finish copying memory image");
    }

    #
    # Move any dirty cache chunks to the hoard cache
    #
    message("INFO", "Client side commit - start moving hoard chunks");
    # XXX
    message("INFO", "Client side commit - finish moving hoard chunks");
    print "Moved $dirtyblocks dirty blocks to the hoard cache.\n"
	if $verbose > 1;

    #
    # Move the cfg.tgz.enc and keyring.enc files into the hoard cache
    #
    $sha1value = `openssl sha1 < $tmpdir/cache/cfg.tgz.enc`;
    chomp($sha1value);
    # XXX
    # rename("$tmpdir/cache/cfg.tgz.enc", "$hoarddir/$sha1value");
    $sha1value = `openssl sha1 < $tmpdir/cache/keyring.enc`;
    chomp($sha1value);
    # XXX
    # rename("$tmpdir/cache/keyring.enc", "$hoarddir/$sha1value");
    message("INFO", "Client side commit - moved memory image into hoard cache");

    # 
    # Sync because we're paranoid
    #
    sys_sync();
    sys_sync();
    return $Isr::ESUCCESS;
}

#
# isr_priv_cleanhoard - perform garbage collection on hoard cache at sync time
# 
sub isr_priv_cleanhoard () {
    my $deletecnt = 0;

    print "Garbage-collecting hoard cache..."
	if $verbose;

    #
    # Simple cases where nothing is hoarded or cached
    #    
    if (!-e "$cachedir/keyring") {
	print "\n"
	    if $verbose;
	return;
    }
    
    # XXX

    print " (Deleted $deletecnt unused chunks)\n"
	if $verbose;
}
