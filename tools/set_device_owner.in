#!!!PERLPATH!!
#
# set_device_owner - chown a Nexus block device newly created by udev
#
# Copyright (C) 2009 Carnegie Mellon University
#
# This program is free software; you can redistribute it and/or modify it
# under the terms of version 2 of the GNU General Public License as published
# by the Free Software Foundation.  A copy of the GNU General Public License
# should have been distributed along with this program in the file
# LICENSE.GPL.
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
# for more details.
#

#
# We used to have
#
#	SUBSYSTEM=="block", KERNEL=="openisr[a-z]", \
#			PROGRAM="/bin/cat /sys/class/openisr/%k/owner", \
#			OWNER="%c", MODE="0600"
#	SUBSYSTEM=="block", KERNEL=="openisr[a-z][1-9]*", \
#			PROGRAM="/bin/cat /sys/class/openisr/%P/owner", \
#			OWNER="%c", MODE="0600"
#
# but udev versions 137-142 do not expand string substitutions in OWNER
# and GROUP fields.  As a result, on Fedora 11 and Ubuntu 9.04, we can't
# dynamically set block device ownership using just udev.  So instead we have
# PROGRAM run this script, which waits for the device node to be created and
# then overrides its ownership.
#
# Fedora 12, on the other hand, uses udev 145, which calls us with SIGUSR1
# (among others) blocked.  This interferes with udevd's use of SIGUSR1 to
# tell "udevadm settle" that udev is no longer busy, causing "udevadm settle"
# to time out.  So, we unblock signals before calling "udevadm settle".  This
# is fixed in udev >= 147.
#

use File::Basename;
use POSIX;
use strict;
use warnings;
use constant {
	TIMEOUT => 15,
	DEBUG => 0
};

sub fail ($) {
	my $msg = shift;

	print STDERR "$msg\n";
	exit 1;
}

exists $ENV{'DEVNAME'}
	or fail "This script must be run by udev.";

# If the udev log priority is set to "debug", stdout and stderr are pipes to
# udevd, which will block until there are no writers, causing "udevadm settle"
# to deadlock.  Close the pipes.
unless (DEBUG) {
	open(STDIN, "/dev/null")
		or fail "Couldn't reopen stdin";
	open(STDOUT, ">/dev/null")
		or fail "Couldn't reopen stdout";
	open(STDERR, ">/dev/null")
		or fail "Couldn't reopen stderr";
}

# Do the work in a child.  The parent exits so that udev will finish
# processing the event.
my $ret = fork();
defined $ret
	or fail "Fork failed";
exit(0)
	if $ret > 0;

# Wait for udev to finish processing the device node.
# Unblock all signals to work around a udev bug in Fedora 12; see above
sigprocmask(POSIX::SIG_SETMASK, POSIX::SigSet->new);
if (-x "/sbin/udevadm") {
	$ret = system("/sbin/udevadm settle --timeout=" . TIMEOUT);
} else {
	$ret = system("/sbin/udevsettle --timeout=" . TIMEOUT);
}
$ret == 0
	or fail "Timed out waiting for udev";

my $devname = $ENV{'DEVNAME'};
my $basename = basename($devname);
$basename =~ s/[0-9]//g;
my $attrfile = "/sys/class/openisr/$basename/owner";

# Validate files
-b $devname
	or fail "$devname is not a block device";
-f $attrfile
	or fail "$attrfile does not exist";

# Get the target UID and chown the device node.
open(ATTR, $attrfile)
	or fail "Couldn't read $attrfile";
my $uid = <ATTR>;
close ATTR;
chomp $uid;
chown(int($uid), -1, $devname);

exit 0;
