#
# openisr.completion - bash completions for isr command
#
# Copyright (C) 2007 Carnegie Mellon University
#
# This software is distributed under the terms of the Eclipse Public
# License, Version 1.0 which can be found in the file named LICENSE.Eclipse.
# ANY USE, REPRODUCTION OR DISTRIBUTION OF THIS SOFTWARE CONSTITUTES
# RECIPIENT'S ACCEPTANCE OF THIS AGREEMENT
#

have isr && {

_isr_find_word() {
	local i
	for (( i=0; $i < ${#COMP_WORDS[@]}; i++ )) ; do
		if [ "${COMP_WORDS[$i]}" = "$1" ] ; then
			echo $i
			return
		fi
	done
	echo -1
}

_isr_parcel_keys() {
	cat ~/.isr/*/parcel.cfg 2>/dev/null | grep "$1" | \
			sed -re "s/^[^=]+= *//"
}

_isr_query_hoard() {
	[ -x !!LIBDIR!!/query -a -r ~/.isr/hoard/hoard.idx ] || return
	!!LIBDIR!!/query ~/.isr/hoard/hoard.idx "$1"
}

_isr_checked_out() {
	compgen -W "`_isr_parcel_keys PARCEL`" $1
}

_isr_remote_parcel() {
	local dir
	dir=~/.isr/completion
	if [ ! -d $dir ] ; then
		mkdir -p $dir 2>/dev/null || return
	fi
	# Proactively remove stale caches to cut down on the amount of
	# semi-sensitive information we leave lying around.
	find $dir -mmin +30 -exec rm {} \; 2>/dev/null
	if [ ! -f $dir/default ] ; then
		isr ls | sed -re "s/.*\[[0-9]+m//" | \
				awk '!/Parcels for/ {print $1}' > $dir/default
	fi
	compgen -W "`cat $dir/default 2>/dev/null`" $1
}

_isr_hoard_uuids() {
	local ret uuid file
	# Get UUIDs of hoard images
	for file in ~/.isr/hoard/img/*-*-*-*.* ; do
		uuid=`echo "$file" | sed -e "s:^.*/::" -e "s:\..*$::"`
		ret=$ret$uuid$'\n'
	done
	# Get UUIDs in hoard cache index
	ret="$ret`_isr_query_hoard 'SELECT uuid FROM parcels'`"
	compgen -W "$ret" $1
}

_isr_servers() {
	local ret
	ret=`_isr_query_hoard "SELECT server FROM parcels"`
	ret=$ret$'\n'`_isr_parcel_keys SERVER`
	compgen -W "$ret" $1
}

_isr_users() {
	local ret
	ret=`_isr_query_hoard 'SELECT user FROM parcels'`
	ret=$ret$'\n'`_isr_parcel_keys USER`
	compgen -W "$ret" $1
}

_isr_parameter_takes_option() {
	case $1 in
	-b|--bwlimit|-L|--longvers|-r|--rollback|-s|--server|-u|--user)
		return 0
		;;
	esac
	return 1
}

_isr_offer_parcel_parameter() {
	local i cur prev
	prev=$1

	# Don't autocomplete if the user is entering an option parameter
	# rather than a parcel name
	_isr_parameter_takes_option $prev && return 1

	# Don't autocomplete if there's already a parcel parameter on the
	# command line.
	# Ignore "isr" and the subcommand name
	for (( i=2; $i < ${#COMP_WORDS[@]}; i++ )) ; do
		cur="${COMP_WORDS[$i]}"
		prev="${COMP_WORDS[$(($i - 1))]}"
		# Ignore the argument we're currently editing
		if [ $i = $COMP_CWORD ] ; then
			continue
		fi
		# Ignore option arguments
		if [ "${cur:0:1}" = "-" ] ; then
			continue
		fi
		# Ignore parameters to option arguments
		if _isr_parameter_takes_option $prev ; then
			continue
		fi
		# We found a parcel parameter
		return 1
	done
	return 0
}

_isr_subcommand_opts() {
	local short long
	case $1 in
	auth|discard|hoard|passwd)
		short="-s -u"
		long="--server --user"
		;;
	checkhoard)
		short="-c"
		long="--checkstate"
		;;
	checkin|ci|sync)
		short="-b -s -u"
		long="--bwlimit --server --user"
		;;
	checkout|co)
		short="-c -d -r -s -u"
		long="--checkstate --disconnected --rollback --server --user"
		;;
	checkp)
		short="-c -e -r -s -u"
		long="--checkstate --remote --rollback --server --user"
		;;
	clean)
		short="-f -s -u"
		long="--force --server --user"
		;;
	ls)
		short="-l -L -s -u"
		long="--long --longvers --server --user"
		;;
	lshoard)
		short="-l"
		long="--long"
		;;
	resume)
		short="-c -d -F -r -s -u"
		long="--checkstate --disconnected --no-fullscreen --rollback --server --user"
		;;
	stat)
		short="-l -s -u"
		long="--long --server --user"
		;;
	esac
	short="-q -v $short"
	long="--quiet --verbose $long"

	if [ "${2:1:1}" = "-" ] ; then
		compgen -W "$long" -- $2
	elif [ "${2:0:1}" = "-" ] ; then
		compgen -W "$short" -- $2
	fi
}

# XXX alt hostname/userid

_isr() {
	local cmd cur prev
	cmd="${COMP_WORDS[1]}"
	cur="$2"
	prev="$3"

	if [ $COMP_CWORD = 1 ] ; then
		COMPREPLY=(`compgen -W "auth checkhoard checkin checkout checkp clean deauth discard help hoard ls lshoard passwd resume rmhoard stat sync version" $cur`)
		return
	fi

	if [ "${cur:0:1}" = "-" ] ; then
		COMPREPLY=(`_isr_subcommand_opts $cmd $cur`)
		return
	fi
	
	if [ "$prev" = "-s" -o "$prev" = "--server" ] ; then
		COMPREPLY=(`_isr_servers $cur`)
		return
	fi
	if [ "$prev" = "-u" -o "$prev" = "--user" ] ; then
		COMPREPLY=(`_isr_users $cur`)
		return
	fi

	# Make sure it's appropriate to offer a parcel parameter here
	_isr_offer_parcel_parameter $prev || return

	case $cmd in
	ci|checkin|discard|stat|sync)
		# Need local parcel
		COMPREPLY=(`_isr_checked_out $cur`)
		;;
	co|checkout|hoard|resume|ls|clean)
		# Need local or remote parcel
		COMPREPLY=(`_isr_remote_parcel $cur`)
		;;
	rmhoard)
		# Need UUID from hoard cache index or image dir
		COMPREPLY=(`_isr_hoard_uuids $cur`)
		;;
	checkp)
		# Need local or remote parcel depending on options
		if [ `_isr_find_word -e` != "-1" -o \
				`_isr_find_word --remote` != "-1" ] ; then
			COMPREPLY=(`_isr_remote_parcel $cur`)
		else
			COMPREPLY=(`_isr_checked_out $cur`)
		fi
		;;
	esac
}
complete -F _isr isr

}
